----- /home/zakaria/zBlog/zblog-frontend/src/app/express/page.tsx -----
"use client";

import React from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "react-oidc-context";

import TopUtilityBar from "@/components/posts/PostCreation/TopUtilityBar";
import PostMetadataSection from "@/components/posts/PostCreation/PostMetadataSection";
import EditorComponent from "@/components/posts/PostCreation/EditorComponent";
import BottomToolbar from "@/components/posts/PostCreation/BottomToolbar";
import { PostDTO } from "@/services/postService";
import { useDraftManager } from "@/hooks/drafts/useDraftManager";
import { useCreatePost } from "@/hooks/post/useCreatePost";

const CreatePostPage: React.FC = () => {
  const auth = useAuth();
  const router = useRouter();

  const {
    draft,
    setDraftField,
    hasChanges,
    autoSaveStatus,
    showResumeModal,
    handleResumeDraft,
    handleDiscardLocalDraft,
    handleDiscardFromEditor,
    clearDraft,
  } = useDraftManager({
    userId: auth.user?.profile?.sub,
    contentType: "express",
  });

  const { create, loading: creatingPost, error: createPostError } = useCreatePost();

  async function handlePublish() {
    if (!draft.title || !draft.content) {
      alert("Title and content are required!");
      return;
    }
    const postPayload: PostDTO = {
      title: draft.title,
      content: draft.content,
      tags: draft.tags,
      published: true,
      authorId: auth.user?.profile?.sub ?? "",
      bannerImageFileId: draft.coverImageKey,
    };
    try {
      const token = auth.user?.access_token;
      const newPost = await create(postPayload, token);
      if (newPost) {
        alert("Post published successfully!");
        clearDraft();
        router.push(`/posts/${newPost.id}`);
      }
    } catch (err) {
      console.error("Create post error:", err);
    }
  }

  function handlePreview() {
    localStorage.setItem(
      `zblog_express_draft_v2_${auth.user?.profile?.sub ?? "guest"}`,
      JSON.stringify(draft)
    );
    router.push("/preview");
  }  

  function setTitle(title: string) {
    setDraftField("title", title);
  }
  function setTags(tags: string[]) {
    setDraftField("tags", tags);
  }
  function setCoverImageUrl(url: string) {
    setDraftField("coverImageUrl", url);
  }
  function setCoverImageKey(key: string) {
    setDraftField("coverImageKey", key);
  }
  function setContent(content: string) {
    setDraftField("content", content);
  }

  return (
    <div className="min-h-screen bg-slate-900 text-slate-100 relative">
      {showResumeModal && (
        <div className="absolute inset-0 bg-black/60 flex items-center justify-center z-50">
          <div className="bg-slate-800 border border-slate-700 rounded-lg p-6 w-80 shadow-xl">
            <h2 className="text-lg font-semibold text-white mb-4">
              Resume previous draft?
            </h2>
            <p className="text-slate-300 text-sm mb-6">
              We found a local draft from a previous session. Continue editing or discard?
            </p>
            <div className="flex justify-end gap-3">
              <button
                onClick={handleDiscardLocalDraft}
                className="px-3 py-1 rounded bg-red-600 hover:bg-red-500 text-white text-sm"
              >
                Discard
              </button>
              <button
                onClick={handleResumeDraft}
                className="px-4 py-1 rounded bg-teal-600 hover:bg-teal-500 text-white text-sm"
              >
                Continue
              </button>
            </div>
          </div>
        </div>
      )}

      <TopUtilityBar
        autoSaveStatus={autoSaveStatus}
        onPreview={handlePreview}
        onPublish={handlePublish}
      />

      {createPostError && (
        <div className="p-2 bg-red-800 text-red-100 text-sm">
          Error creating post: {createPostError}
        </div>
      )}
      {creatingPost && (
        <div className="p-2 text-teal-400 text-sm">
          Publishing post, please wait...
        </div>
      )}

      <PostMetadataSection
        title={draft.title}
        onTitleChange={setTitle}
        tags={draft.tags}
        onTagsChange={setTags}
        coverImageUrl={draft.coverImageUrl}
        onCoverImageUrlChange={setCoverImageUrl}
        coverImageKey={draft.coverImageKey}
        onCoverImageKeyChange={setCoverImageKey}
      />

      <div className="p-4">
        <EditorComponent content={draft.content} onContentChange={setContent} />
      </div>

      <BottomToolbar
        content={draft.content}
        readingTime="2 min"
        onDiscard={handleDiscardFromEditor}
      />
    </div>
  );
};

export default CreatePostPage;


----- /home/zakaria/zBlog/zblog-frontend/src/components/Fallback/Fallback.tsx -----
import React from 'react';
import Lottie from 'lottie-react';
import loadingAnimation from '@/assets/animations/loadingAnimation.json';
import '@/styles/Fallback.css'; 

interface FallbackProps {
  message: string;
}

const Fallback: React.FC<FallbackProps> = ({ message }) => {
  return (
    <div className="fallback-wrapper">
      <div className="fallback-inner">
        <Lottie animationData={loadingAnimation} loop className="fallback-animation" />
        <p className="fallback-message">{message}</p>
      </div>
    </div>
  );
};

export default Fallback;


----- /home/zakaria/zBlog/zblog-frontend/src/components/Fallback/ErrorBoundary.tsx -----
"use client";

import React from "react";

type Props = {
  children: React.ReactNode;
  fallback: React.ReactNode;
};

type State = {
  hasError: boolean;
};

export default class ErrorBoundary extends React.Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(_: Error): State {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) return this.props.fallback;
    return this.props.children;
  }
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/tags/TagCard.tsx -----
"use client"

import React from "react"
import Image from "next/image"
import { motion } from "framer-motion"

export interface TagCardProps {
  title: string
  image: string
  description?: string
  onClick?: () => void
}

export default function TagCard({ title, image, description, onClick }: TagCardProps) {
  return (
    <motion.div
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={onClick}
      className="relative h-64 w-full rounded-xl shadow-md cursor-pointer overflow-hidden"
    >
      {/* Background Image */}
      <Image
        src={image}
        alt={title}
        fill
        className="object-cover object-center brightness-75"
        sizes="(max-width: 768px) 100vw,
               (max-width: 1200px) 50vw,
               33vw"
      />

      {/* Overlay */}
      <div className="absolute inset-0 bg-black/40" />

      {/* Content */}
      <div className="relative z-10 flex flex-col items-center justify-center text-center h-full px-4">
        <h3 className="text-white text-2xl font-bold mb-2">#{title}</h3>
        {description && (
          <p className="text-gray-200 text-sm max-w-xs">{description}</p>
        )}
      </div>
    </motion.div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/HeroSection.tsx -----
"use client"

import { motion } from "framer-motion"
import Link from "next/link"
import { useEffect } from "react"
import { useAuth } from "react-oidc-context"

export interface HeroSectionProps {
  title?: string
  subtitle?: string
  buttonText?: string
}

export default function HeroSection({
  title = "Write posts on multiple topics",
  subtitle = "Create and organize posts with images, videos, code snippets, and more. Execute live code, share your thoughts, and explore new ideas.",
  buttonText = "Join Now",
}: HeroSectionProps) {

  const auth = useAuth()

  useEffect(() => {
    if (auth.isAuthenticated && auth.user) {
      const token = auth.user.access_token
      console.log("Authorization Header:", `Bearer ${token}`)
    }
  }, [auth.isAuthenticated, auth.user])

  
  return (
    <section className="relative overflow-hidden">
      {/* Background decorative elements */}
      <div className="absolute inset-0 -z-10">
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          transition={{ duration: 1, ease: "easeOut" }}
          className="absolute top-0 left-0 w-72 h-72 bg-slate-500/10 rounded-full filter blur-3xl"
        />
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          transition={{ duration: 1, delay: 0.2, ease: "easeOut" }}
          className="absolute bottom-0 right-0 w-72 h-72 bg-slate-600/10 rounded-full filter blur-3xl"
        />
      </div>

      <div className="flex flex-col md:flex-row items-center gap-12 py-16">
        <motion.div
          initial={{ opacity: 0, x: -50 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ type: "spring", stiffness: 80, damping: 12, delay: 0.2 }}
          className="md:w-1/2 space-y-6"
        >
          <h1 className="text-4xl md:text-6xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-slate-200 to-slate-400">
            {title}
          </h1>
          <p className="text-slate-400 text-lg md:text-xl max-w-xl">{subtitle}</p>
          {/* Button Animation: transform origin set to center */}
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.6, ease: "easeOut", delay: 0.5 }}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            style={{ originX: 0.5, originY: 0.5 }}
            className="inline-block ml-6" // <-- SHIFT BUTTON RIGHT
          >
            <Link href="/register" className="inline-block">
              <button className="px-8 py-4 bg-gradient-to-r from-slate-700 to-slate-800 hover:from-slate-600 hover:to-slate-700 text-slate-200 rounded-lg font-medium shadow-xl transition-all hover:shadow-slate-500/20">
                {buttonText}
              </button>
            </Link>
          </motion.div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, x: 50 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ type: "spring", stiffness: 80, damping: 12, delay: 0.4 }}
          className="md:w-1/2"
        >
          <div className="relative">
            <motion.div
              initial={{ scale: 0.95, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              transition={{ duration: 0.8, delay: 0.5 }}
              className="absolute inset-0 bg-gradient-to-r from-slate-800 to-slate-700 rounded-2xl transform rotate-6 opacity-40 blur-xl"
            />
            <div className="relative bg-gradient-to-r from-slate-800 to-slate-700 p-8 rounded-2xl shadow-2xl">
              <div className="h-64 flex items-center justify-center">
                <span className="text-slate-400">Premium Content Preview</span>
              </div>
            </div>
          </div>
        </motion.div>
      </div>
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/PostsSection.tsx -----
"use client"

import Link from "next/link"
import { motion } from "framer-motion"

export interface Post {
  id: number
  title: string
  excerpt: string
  date: string
  image?: string
}

const defaultPosts: Post[] = [
  {
    id: 1,
    title: "Understanding Microservices",
    excerpt: "A deep dive into microservices architecture and best practices.",
    date: "2025-03-01",
    image: "https://picsum.photos/300/200?random=1",
  },
  {
    id: 2,
    title: "Mastering Next.js",
    excerpt: "Learn how to build fast, scalable web apps with Next.js.",
    date: "2025-03-05",
    image: "https://picsum.photos/300/200?random=2",
  },
  {
    id: 3,
    title: "Frontend Animations with Framer Motion",
    excerpt: "Bring your UI to life with smooth and interactive animations.",
    date: "2025-03-10",
    image: "https://picsum.photos/300/200?random=3",
  },
]

export default function PostsSection({ posts = defaultPosts }: { posts?: Post[] }) {
  return (
    <section className="py-12">
      <h2 className="text-2xl font-bold mb-6 text-slate-100">Latest Posts</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {posts.map((post) => (
          <motion.div
            key={post.id}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ type: "spring", stiffness: 80, damping: 12, delay: post.id * 0.2 }}
            className="bg-slate-800 border border-slate-700 rounded-lg shadow-md overflow-hidden"
          >
            {post.image && (
              <img
                src={post.image}
                alt={post.title}
                className="w-full h-40 object-cover"
              />
            )}
            <div className="p-4">
              <h3 className="font-semibold text-slate-100">{post.title}</h3>
              <p className="text-slate-400 text-sm">{post.excerpt}</p>
              <p className="text-slate-500 text-xs mt-2">{post.date}</p>
              <Link
                href={`/posts/${post.id}`}
                className="mt-2 inline-block text-blue-400 hover:underline"
              >
                Read More
              </Link>
            </div>
          </motion.div>
        ))}
      </div>
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/ArticlesSection.tsx -----
"use client"

import { motion } from "framer-motion"

export interface Article {
  id: number
  title: string
  summary: string
  image?: string
}

const defaultArticles: Article[] = [
  {
    id: 1,
    title: "Article on UI Design",
    summary: "Tips and tricks for modern, responsive UI design.",
    image: "https://picsum.photos/300/200?random=4",
  },
  {
    id: 2,
    title: "Understanding Auth Flows",
    summary: "A comprehensive guide to authentication in web apps.",
    image: "https://picsum.photos/300/200?random=5",
  },
  {
    id: 3,
    title: "Deploying with Kubernetes",
    summary: "Step-by-step instructions for container orchestration.",
    image: "https://picsum.photos/300/200?random=6",
  },
]

export default function ArticlesSection({
  articles = defaultArticles,
}: {
  articles?: Article[]
}) {
  return (
    <section className="py-12">
      <h2 className="text-2xl font-bold mb-6 text-slate-100">Seat Articles</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {articles.map((article) => (
          <motion.div
            key={article.id}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ type: "spring", stiffness: 80, damping: 12, delay: article.id * 0.2 }}
            className="bg-slate-800 border border-slate-700 rounded-lg shadow-md overflow-hidden"
          >
            {article.image && (
              <img
                src={article.image}
                alt={article.title}
                className="w-full h-40 object-cover"
              />
            )}
            <div className="p-4">
              <h3 className="font-semibold text-slate-100">{article.title}</h3>
              <p className="text-slate-400 text-sm">{article.summary}</p>
            </div>
          </motion.div>
        ))}
      </div>
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/FeaturesSection.tsx -----
"use client"

import FeatureCard from "./FeatureCard"
import { FileText, TerminalSquare, Server } from "lucide-react"

export interface Feature {
  id: number
  title: string
  description: string
  icon?: React.ReactNode
}

const defaultFeatures: Feature[] = [
  {
    id: 1,
    title: "Create rich posts",
    description: "Write and organize content with images, videos, and more.",
    icon: <FileText className="w-12 h-12 text-slate-300" />,
  },
  {
    id: 2,
    title: "Run live code",
    description: "Test and showcase your code snippets directly in your posts.",
    icon: <TerminalSquare className="w-12 h-12 text-slate-300" />,
  },
  {
    id: 3,
    title: "Share your thoughts",
    description: "Engage with an audience and share your expertise.",
    icon: <Server className="w-12 h-12 text-slate-300" />,
  },
]

export default function FeaturesSection({
  features = defaultFeatures,
}: {
  features?: Feature[]
}) {
  return (
    <section className="grid grid-cols-1 md:grid-cols-3 gap-8 py-12">
      {features.map((feature) => (
        <FeatureCard
          key={feature.id}
          title={feature.title}
          description={feature.description}
          icon={feature.icon}
        />
      ))}
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/FeatureCard.tsx -----
"use client"

import React from "react"
import { FileText, TerminalSquare, Server } from "lucide-react"
import { motion } from "framer-motion"

export interface FeatureCardProps {
  title: string
  description: string
  icon?: React.ReactNode
}

export default function FeatureCard({
  title,
  description,
  icon,
}: FeatureCardProps) {
  return (
    <motion.div
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
      className="flex flex-col items-center text-center p-6 border border-slate-700 rounded-lg shadow-md bg-slate-800"
      transition={{ type: "spring", stiffness: 100, damping: 10 }}
    >
      <div className="mb-4">
        {icon ? (
          icon
        ) : (
          <FileText className="w-12 h-12 text-slate-300" />
        )}
      </div>
      <h3 className="font-semibold text-slate-100 mb-2">{title}</h3>
      <p className="text-slate-400 text-sm">{description}</p>
    </motion.div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/AnimatedBackground.tsx -----
"use client"

import { useCallback } from "react"
import Particles from "react-tsparticles"
import { loadSlim } from "tsparticles-slim" 

export default function AnimatedBackground() {
  const particlesInit = useCallback(async (engine: any) => {
    await loadSlim(engine)
  }, [])

  return (
    <Particles
      id="tsparticles"
      init={particlesInit}
      options={{
        fullScreen: { enable: true, zIndex: -1 },
        background: {
          color: { value: "#0f172a" },
        },
        fpsLimit: 60,
        interactivity: {
          events: {
            onHover: { enable: true, mode: "repulse" },
            resize: true,
          },
          modes: {
            repulse: { distance: 100, duration: 0.4 },
          },
        },
        particles: {
          color: { value: "#3b82f6" },
          links: {
            color: "#3b82f6",
            distance: 150,
            enable: true,
            opacity: 0.3,
            width: 1,
          },
          collisions: { enable: true },
          move: {
            direction: "none",
            enable: true,
            outModes: { default: "bounce" },
            speed: 1,
          },
          number: { value: 50, density: { enable: true, area: 800 } },
          opacity: { value: 0.5 },
          shape: { type: "circle" },
          size: { value: { min: 1, max: 4 } },
        },
        detectRetina: true,
      }}
    />
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/Navbar.tsx -----
"use client"

import React, { useState, useEffect } from "react"
import Link from "next/link"
import { useAuth } from "react-oidc-context"
import { Search, UserCircle, MoreHorizontal } from "lucide-react"
import { motion } from "framer-motion"
import Lottie from "lottie-react"
import zLogoAnimation from "@/assets/animations/z-logo.json"

export default function Navbar() {
  const auth = useAuth()

  const [location, setLocation] = useState<string>("Fetching location...")
  const [temperature, setTemperature] = useState<string>("Fetching temperature...")
  const [time, setTime] = useState<string>("Fetching time...")
  const [isSearchOpen, setIsSearchOpen] = useState<boolean>(false)
  const [isProfileDropdownOpen, setIsProfileDropdownOpen] = useState<boolean>(false)
  const [isAvatarHovered, setIsAvatarHovered] = useState<boolean>(false)

  const navItems = [
    { label: "Recent", href: "/recent" },
    { label: "Tags", href: "/tags" },
    { label: "Explore", href: "/posts" },
    ...(auth.isAuthenticated ? [{ label: "Express", href: "/express" }] : []),
    { label: "About", href: "/about" },
  ]  

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (isProfileDropdownOpen) {
        const target = event.target as HTMLElement
        if (!target.closest('.profile-dropdown')) {
          setIsProfileDropdownOpen(false)
        }
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [isProfileDropdownOpen])

  // Get user's current location, time, and temperature
  useEffect(() => {
    const getLocationData = async () => {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(async (position) => {
          const lat = position.coords.latitude
          const lon = position.coords.longitude

          // Fetching weather data
          const weatherResponse = await fetch(
            `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=6c70008d80c4e8b1f295cdf5b6a9bfde&units=metric`
          )
          const weatherData = await weatherResponse.json()
          setLocation(weatherData.name)
          setTemperature(`${weatherData.main.temp}°C`)

          // Fetching time data based on public IP
          const timeResponse = await fetch("http://worldtimeapi.org/api/ip")
          const timeData = await timeResponse.json()

          // Format the time into a readable format (e.g. "8:23 AM, March 29, 2025")
          const date = new Date(timeData.datetime)
          const formattedTime = date.toLocaleString("en-US", {
            weekday: "short",
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            hour12: true,
          })
          setTime(formattedTime) // Setting formatted time
        })
      } else {
        console.log("Geolocation not supported")
      }
    }

    getLocationData()
  }, [])

  return (
    <header className="grid grid-cols-[auto_1fr_auto_auto] grid-rows-[auto_auto] text-white border-b border-slate-800 bg-slate-900">
      {/* Brand - spans both rows */}
      <div className="row-span-2 bg-slate-800 flex items-center justify-center px-6 border-r border-slate-700">
        <Link href="/" className="text-center">
          {/* Replace Z letter with Lottie animation */}
          <div className="w-12 h-12">
            <Lottie animationData={zLogoAnimation} loop autoplay />
          </div>
          <div className="text-xs text-blue-400 tracking-wide">ZBlog</div>
        </Link>
      </div>

      {/* Welcome + Time/CTA Top Bar */}
      <div className="col-span-3 flex items-center justify-between px-6 h-10 border-b border-slate-800">
        <p className="text-sm text-slate-400 text-center flex-1">
          Welcome to ZBlog — A blog made by me for you
        </p>
        <div className="flex items-center h-full">
          <div className="px-6 h-full flex items-center border-l border-slate-800">
            <span className="text-sm text-slate-400">{time} — {temperature}</span>
          </div>
          <div className="px-6 h-full flex items-center border-l border-r border-slate-800">
            <span className="text-blue-400 font-medium cursor-pointer hover:text-white transition-colors">
              Blog like you never did before
            </span>
          </div>
        </div>
      </div>

      {/* Navigation Row */}
      <div className="col-span-3 flex items-center justify-between px-0 h-14 border-t border-slate-800">
        {/* Navigation Items */}
        <nav className="flex h-full">
        {navItems.map((item, idx) => (
          <Link
            key={item.label}
            href={item.href}
            className={`
              flex items-center px-6 h-full 
              text-sm uppercase tracking-wide 
              text-slate-300 hover:text-white 
              relative group transition-all
              ${idx !== 0 ? 'border-l border-slate-800' : ''}
              ${idx === navItems.length - 1 ? 'border-r border-slate-800' : ''}
            `}
          >
            {item.label}
            <div className="absolute bottom-0 left-0 w-full h-[2px] bg-gradient-to-r from-blue-500 to-teal-500 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-200" />
          </Link>
        ))}
      </nav>

        {/* Search + Auth */}
        {/* Search + Auth */}
  <div className="flex h-full">
    <div className="relative h-full flex items-center px-6 border-l border-slate-800">
      <div className="flex items-center gap-3">
        {isSearchOpen && (
          <motion.input
            initial={{ width: 0, opacity: 0 }}
            animate={{ width: "200px", opacity: 1 }}
            exit={{ width: 0, opacity: 0 }}
            type="text"
            placeholder="Type to search..."
            className="bg-slate-800 text-sm text-slate-200 px-3 py-1.5 rounded-lg border border-slate-700 focus:outline-none focus:border-blue-500/50"
          />
        )}
        <Search 
          className="w-4 h-4 text-slate-400 hover:text-white cursor-pointer" 
          onClick={() => setIsSearchOpen(!isSearchOpen)}
        />
      </div>
    </div>

    {auth.isAuthenticated ? (
  <div className="relative h-full flex items-center px-6 border-l border-r border-slate-800">
    <div
      className="flex items-center gap-2 cursor-pointer"
      onClick={() => setIsProfileDropdownOpen(!isProfileDropdownOpen)}
    >
      <UserCircle className="w-5 h-5 text-slate-200" />
      <span className="text-sm hidden md:inline text-slate-300">
        {auth.user?.profile.email}
      </span>
      <MoreHorizontal className="text-slate-400 w-4 h-4" />
    </div>
    
    {/* Dropdown Menu */}
    {isProfileDropdownOpen && (
      <>
        {/* Overlay */}
        <div 
          className="fixed inset-0 bg-black/20 z-40" 
          onClick={() => setIsProfileDropdownOpen(false)}
        />
        
        {/* Dropdown Content */}
        <div 
          className="absolute right-0 top-[calc(100%+1px)] w-56 bg-slate-800 rounded-lg shadow-lg border border-slate-700 z-50 overflow-hidden"
          onClick={(e) => e.stopPropagation()}
        >
          
          {/* Menu Items */}
          <div className="p-2">
            <button
              onClick={() => {
                auth.removeUser();
                setIsProfileDropdownOpen(false);
              }}
              className="w-full flex items-center gap-2 px-3 py-2 text-sm text-red-400 hover:text-red-300 hover:bg-slate-700/50 rounded-md transition-colors text-left"
            >
              Logout
            </button>
          </div>
        </div>
      </>
    )}
  </div>
    ) : (
      <div className="h-full flex items-center px-6 border-l border-r border-slate-800">
        <div className="flex items-center gap-4">
          <button
            onClick={() => auth.signinRedirect()}
            className="text-sm text-slate-300 hover:text-white"
          >
            Login
          </button>
          <div className="w-px h-4 bg-slate-800" />
          <Link
            href="/register"
            className="text-sm text-slate-300 hover:text-white"
          >
            Register
          </Link>
        </div>
      </div>
    )}
  </div>
</div>
    </header>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/PersonalNote.tsx -----
"use client";

import React from "react";

export default function PersonalNote() {
  return (
    <section className="grid gap-8">
      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-500">
        My Journey
      </h2>
      <div className="grid gap-6 text-lg leading-relaxed">
        <p className="text-slate-200">
          zBlog is my full‑stack learning project — built from scratch with no
          generators, no shortcuts. I'm continuously evolving my skills from
          GraphQL schemas to OAuth security, all while refining a creative and
          seamless developer experience.
        </p>
        <p className="text-slate-300">
          Every new feature is a step toward mastering modern software
          engineering, and zBlog is the living document of that journey.
        </p>
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/ContactSection.tsx -----
"use client";

import React from "react";
import { GithubIcon, Mail } from "lucide-react";

export default function ContactSection() {
  return (
    <section className="grid gap-8">
      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-500">
        Get in Touch
      </h2>
      <div className="grid gap-6">
        <p className="text-lg text-slate-200">
          I'm always open to collaboration, code reviews, or feedback.
        </p>
        <div className="flex flex-col sm:flex-row gap-4">
          <a
            href="https://github.com/zakariafarih"
            target="_blank"
            rel="noreferrer"
            className="flex items-center gap-3 px-6 py-3 bg-slate-800/50 rounded-xl border border-slate-700 hover:border-blue-500/50 hover:bg-slate-800 transition-all group"
          >
            <GithubIcon className="w-5 h-5 text-blue-400 group-hover:text-blue-300" />
            <span className="text-slate-200 group-hover:text-white">GitHub</span>
          </a>
          <a
            href="mailto:zakariafarih142@gmail.com"
            className="flex items-center gap-3 px-6 py-3 bg-slate-800/50 rounded-xl border border-slate-700 hover:border-teal-500/50 hover:bg-slate-800 transition-all group"
          >
            <Mail className="w-5 h-5 text-teal-400 group-hover:text-teal-300" />
            <span className="text-slate-200 group-hover:text-white">Email</span>
          </a>
        </div>
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/TechStackOverview.tsx -----
"use client";

import React from "react";

export default function TechStackOverview() {
  return (
    <section className="grid gap-8">
      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-500">
        Tech Stack & Architecture
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* Backend */}
        <div className="bg-slate-800/50 p-6 rounded-2xl shadow-lg border border-slate-700 hover:border-blue-500/50 transition-colors">
          <h3 className="text-xl font-semibold mb-4 text-blue-400">Backend</h3>
          <ul className="space-y-3 text-slate-300">
            {[
              "Spring Boot 3+ microservices",
              "AWS Cognito + OIDC authentication",
              "MySQL on AWS RDS",
              "HTTP/Kafka/event-driven comms",
              "Dockerized, AWS deployment-ready",
            ].map((item) => (
              <li key={item} className="flex items-center gap-2">
                <div className="w-1.5 h-1.5 rounded-full bg-blue-500" />
                {item}
              </li>
            ))}
          </ul>
        </div>
        {/* Frontend */}
        <div className="bg-slate-800/50 p-6 rounded-2xl shadow-lg border border-slate-700 hover:border-teal-500/50 transition-colors">
          <h3 className="text-xl font-semibold mb-4 text-teal-400">Frontend</h3>
          <ul className="space-y-3 text-slate-300">
            {[
              "Next.js (App Router)",
              "Shadcn/ui & Tailwind CSS",
              "Framer Motion for animations",
              "Rich TinyMCE editor (dark mode)",
              "Modular, component‑based architecture",
            ].map((item) => (
              <li key={item} className="flex items-center gap-2">
                <div className="w-1.5 h-1.5 rounded-full bg-teal-500" />
                {item}
              </li>
            ))}
          </ul>
        </div>
        {/* DevOps */}
        <div className="bg-slate-800/50 p-6 rounded-2xl shadow-lg border border-slate-700 hover:border-purple-500/50 transition-colors">
          <h3 className="text-xl font-semibold mb-4 text-purple-400">DevOps</h3>
          <ul className="space-y-3 text-slate-300">
            {[
              "Dockerized services",
              "AWS ECS, API Gateway",
              "CI/CD pipelines",
              "Monitoring & logging",
              "AWS Secrets Manager",
            ].map((item) => (
              <li key={item} className="flex items-center gap-2">
                <div className="w-1.5 h-1.5 rounded-full bg-purple-500" />
                {item}
              </li>
            ))}
          </ul>
        </div>
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/AboutHeader.tsx -----
"use client";

import React from "react";
import { motion } from "framer-motion";

export default function AboutHeader() {
  return (
    <section className="grid gap-8">
      <motion.h1
        className="text-5xl md:text-6xl font-bold bg-gradient-to-r from-blue-500 to-teal-500 text-transparent bg-clip-text"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
      >
        About zBlog
      </motion.h1>
      <div className="grid gap-6">
        <p className="text-xl text-slate-200 leading-relaxed">
          zBlog is a sleek, developer-centric blogging platform built with modern
          microservice architecture and cutting-edge UI design. It's a technical
          playground for creative developers.
        </p>
        <blockquote className="border-l-4 border-blue-500 pl-6 py-1">
          <p className="text-lg text-slate-300 italic">
            "zBlog is more than a portfolio piece — it's my technical playground to
            push the limits of what I can create while sharing the journey with the
            community."
          </p>
        </blockquote>
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/UpcomingFeatures.tsx -----
"use client";

import React from "react";

export default function UpcomingFeatures() {
  const features = [
    "Comments with nested replies and emoji reactions",
    "Editor preview mode integration",
    "Post scheduling and automated notifications",
    "Advanced file versioning and media explorer",
    "Full public sharing & improved collaboration features",
  ];

  return (
    <section className="grid gap-8">
      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-500">
        What's Next
      </h2>
      <div className="grid gap-4">
        {features.map((feature, index) => (
          <div
            key={feature}
            className="flex items-center gap-4 p-4 bg-slate-800/50 rounded-xl border border-slate-700"
          >
            <span className="text-blue-500 font-mono text-sm">0{index + 1}</span>
            <p className="text-slate-200">{feature}</p>
          </div>
        ))}
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/card.tsx -----
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/select.tsx -----
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/CyberpunkSelect.tsx -----
"use client";

import * as React from "react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { motion } from "framer-motion";
import clsx from "clsx";

interface CyberpunkSelectProps {
  value: string;
  onChange: (value: string) => void;
}

export default function CyberpunkSelect({ value, onChange }: CyberpunkSelectProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: -6 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.25 }}
      className="w-full h-full"
    >
      <Select value={value} onValueChange={onChange}>
        <SelectTrigger
          className={clsx(
            "w-full h-full px-3 py-1.5 text-sm bg-transparent text-slate-200",
            "border-none focus:outline-none focus:ring-0 uppercase tracking-wide",
            "neon-glow"
          )}
        >
          <SelectValue placeholder="Sort..." />
        </SelectTrigger>
        <SelectContent
          className={clsx(
            "bg-slate-900 border border-slate-700 text-slate-300 rounded-none",
            "neon-glow"
          )}
        >
          <SelectItem value="recent">Newest First</SelectItem>
          <SelectItem value="popular">Most Popular</SelectItem>
          <SelectItem value="mostLiked">Most Liked</SelectItem>
        </SelectContent>
      </Select>
    </motion.div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/dropdown-menu.tsx -----
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/button.tsx -----
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/ExplorePostsFilter.tsx -----
"use client"

import React from "react"
import { Search, X } from "lucide-react"
import clsx from "clsx"
import Select from "react-select"

export interface FilterState {
  keyword: string
  tag: string
  dateRange: string
  sort: string
}

interface ExplorePostsFilterProps {
  filters: FilterState
  setFilters: React.Dispatch<React.SetStateAction<FilterState>>
}

const TAG_OPTIONS = [
  "Coding", "TypeScript", "Microservices", "Design", "Cloud",
  "AI", "VS Code", "Python", "Data Science"
].map((tag) => ({ label: tag, value: tag }))

const DATE_OPTIONS = [
  { label: "Today", value: "today" },
  { label: "Last 7 days", value: "7d" },
  { label: "This month", value: "month" },
  { label: "All", value: "all" },
]

export default function ExplorePostsFilter({
  filters,
  setFilters,
}: ExplorePostsFilterProps) {
  const handleChange = (key: keyof FilterState, value: string) => {
    setFilters((prev) => ({ ...prev, [key]: value }))
  }

  return (
    <div className="space-y-4 mb-8 relative z-50">
      {/* Top Filters Row */}
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        {/* Search and Sort */}
        <div className="flex flex-1 gap-3">
          {/* Search Input */}
          <div className="relative w-full max-w-sm">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 w-4 h-4" />
            <input
              type="text"
              value={filters.keyword}
              onChange={(e) => handleChange("keyword", e.target.value)}
              placeholder="Search posts"
              className="w-full bg-slate-800 border border-slate-700 rounded-lg py-2 pl-10 pr-4 text-sm text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          {/* Sort Dropdown */}
          <select
            value={filters.sort}
            onChange={(e) => handleChange("sort", e.target.value)}
            className="bg-slate-800 border border-slate-700 rounded-lg py-2 px-3 text-sm text-white"
          >
            <option value="recent">All time</option>
            <option value="popular">Most Liked</option>
            <option value="comments">Most Commented</option>
          </select>
        </div>

        {/* Date Range + Tags */}
        <div className="flex flex-wrap gap-3 items-center">
          {/* Date Buttons */}
          {DATE_OPTIONS.map((option) => (
            <button
              key={option.value}
              onClick={() => handleChange("dateRange", option.value)}
              className={clsx(
                "px-4 py-1.5 rounded-lg text-sm font-medium border",
                filters.dateRange === option.value
                  ? "bg-blue-600 text-white border-blue-600"
                  : "bg-slate-800 text-slate-300 border-slate-700 hover:bg-slate-700"
              )}
            >
              {option.label}
            </button>
          ))}

          {/* Tag Select */}
          <div className="w-64 relative z-50">
          <Select
            options={TAG_OPTIONS}
            isMulti
            placeholder="Tags"
            classNamePrefix="react-select"
            onChange={(selected) => {
                const value = selected.map((opt) => opt.value).join(",")
                handleChange("tag", value)
            }}
            value={TAG_OPTIONS.filter((opt) => filters.tag.split(",").includes(opt.value))}
            styles={{
                control: (base) => ({
                ...base,
                backgroundColor: "#1e293b",
                borderColor: "#334155",
                color: "white",
                minHeight: "38px",
                }),
                menu: (base) => ({
                ...base,
                backgroundColor: "#1e293b",
                zIndex: 9999,
                }),
                option: (base, state) => ({
                ...base,
                backgroundColor: state.isFocused
                    ? "#2563eb" 
                    : "#1e293b", 
                color: state.isFocused ? "white" : "#e2e8f0", 
                cursor: "pointer",
                }),
                multiValue: (base) => ({ ...base, backgroundColor: "#2563eb" }),
                multiValueLabel: (base) => ({ ...base, color: "white" }),
                input: (base) => ({ ...base, color: "white" }),
            }}
            />
          </div>
        </div>
      </div>

      {/* Tag Pills below search */}
      {filters.tag && filters.tag.split(",").length > 0 && (
        <div className="flex flex-wrap gap-2 pl-1">
          {filters.tag.split(",").map((t) => (
            <div
              key={t}
              className="flex items-center bg-blue-600 text-white px-3 py-1 rounded-full text-sm font-medium"
            >
              {t}
              <button
                onClick={() => {
                  const remaining = filters.tag
                    .split(",")
                    .filter((tag) => tag !== t)
                    .join(",")
                  handleChange("tag", remaining)
                }}
                className="ml-2 hover:text-slate-300"
              >
                <X className="w-4 h-4" />
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/NoPostsHolder.tsx -----
"use client"

import React from "react"
import Lottie from "lottie-react"
import emptyStateAnimation from "@/assets/animations/empty-state.json"

export default function NoPostsHolder() {
  return (
    <div className="flex flex-col items-center justify-center py-16">
      <div className="w-64 h-64">
        <Lottie animationData={emptyStateAnimation} loop={true} />
      </div>
      <p className="mt-4 text-gray-400 text-center">
        Oops! We couldn&apos;t find any posts matching your filters.
      </p>
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/BottomToolbar.tsx -----
"use client";

import React from "react";

interface BottomToolbarProps {
  content: string;
  readingTime: string;
  onDiscard: () => void;
}

const BottomToolbar: React.FC<BottomToolbarProps> = ({
  content,
  readingTime,
  onDiscard,
}) => {
  // Compute word count simply by splitting on whitespace
  const wordCount =
    content.trim() === "" ? 0 : content.trim().split(/\s+/).length;
    
  return (
    <div className="fixed bottom-0 left-0 right-0 bg-slate-800 p-3 flex justify-between items-center text-sm text-slate-400">
      <div>
        <span>Word Count: {wordCount}</span>
        <span className="ml-4">Read Time: {readingTime}</span>
      </div>
      <div>
        <button
          onClick={onDiscard}
          className="hover:underline text-red-400"
        >
          Discard Changes
        </button>
      </div>
    </div>
  );
};

export default BottomToolbar;


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/EditorComponent.tsx -----
"use client";

import React, { useEffect, useRef, useState } from "react";
import dynamic from "next/dynamic";
import hljs from "highlight.js";
import "highlight.js/styles/github-dark.css";
import type { Editor } from 'tinymce';

// 1. Dynamically import the TinyMCE React wrapper (to avoid SSR).
const TinyMCEEditor = dynamic(
  () => import("@tinymce/tinymce-react").then((mod) => mod.Editor),
  { ssr: false }
);

interface EditorComponentProps {
  content: string;
  onContentChange: (val: string) => void;
}

/**
 * A production-ready, dark-mode TinyMCE with:
 * - Autoresize (no internal scroll)
 * - Codesample plugin for code blocks
 * - Forced paragraphs so you can type after code
 * - No iframes or extra containers
 */
export default function EditorComponent({
  content,
  onContentChange,
}: EditorComponentProps) {
  const [tinyLoaded, setTinyLoaded] = useState(false);
  const previewRef = useRef<HTMLDivElement>(null);

  // 2. Dynamically load TinyMCE on the client (core + plugins).
  useEffect(() => {
    async function loadTinyMCE() {
      if (typeof window !== "undefined") {
        // Core, icons, and theme
        await import("tinymce/tinymce");
        await import("tinymce/icons/default");
        await import("tinymce/themes/silver");

        // Plugins
        await Promise.all([
          import("tinymce/plugins/advlist"),
          import("tinymce/plugins/autolink"),
          import("tinymce/plugins/lists"),
          import("tinymce/plugins/link"),
          import("tinymce/plugins/image"),
          import("tinymce/plugins/charmap"),
          import("tinymce/plugins/preview"),
          import("tinymce/plugins/anchor"),
          import("tinymce/plugins/searchreplace"),
          import("tinymce/plugins/visualblocks"),
          import("tinymce/plugins/fullscreen"),
          import("tinymce/plugins/insertdatetime"),
          import("tinymce/plugins/media"),
          import("tinymce/plugins/table"),
          import("tinymce/plugins/help"),
          import("tinymce/plugins/wordcount"),
          import("tinymce/plugins/codesample"),
          import("tinymce/plugins/autoresize"),
        ]);
      }
      setTinyLoaded(true);
    }
    loadTinyMCE();
  }, []);

  // 3. Use Highlight.js in the preview (optional).
  useEffect(() => {
    if (previewRef.current) {
      previewRef.current.innerHTML = content;
      previewRef.current.querySelectorAll("pre code").forEach((block) => {
        hljs.highlightElement(block as HTMLElement);
      });
    }
  }, [content]);

  if (!tinyLoaded) {
    // Simple loading indicator instead of a blank screen
    return <div className="text-slate-300">Loading editor...</div>;
  }

  return (
    <div className="w-full">
      <TinyMCEEditor
        value={content}
        onEditorChange={onContentChange}
        init={{
          // 4. Serve TinyMCE resources from /tinymce (copy the entire folder to /public/tinymce)
          base_url: "/tinymce",

          // 5. No internal scroll – just grows with content
          plugins:
            "autoresize advlist autolink lists link image charmap preview anchor " +
            "searchreplace visualblocks fullscreen insertdatetime media table " +
            "help wordcount codesample",
          autoresize_min_height: 300,
          autoresize_overflow_padding: 10,

          menubar: false,
          statusbar: false,
          forced_root_block: "p",

          // 6. Provide a convenient toolbar – includes codesample
          toolbar:
            "undo redo | formatselect | " +
            "bold italic backcolor | alignleft aligncenter alignright alignjustify | " +
            "bullist numlist outdent indent | removeformat | codesample | help",

          // 7. Dark theme from self-hosted assets (with forced dark background in content)
          skin: "oxide-dark",
          skin_url: "/tinymce/skins/ui/oxide-dark",
          content_css: "/tinymce/skins/content/dark/content.min.css",
          content_style: `
            body {
              background: #0f172a;
              color: #f1f5f9;
              font-family: sans-serif;
              padding: 1rem;
            }
            a { color: #7dd3fc; }
          `,
          branding: false,

          // 8. The codesample plugin – built-in code insertion, no weird containers
          codesample_languages: [
            { text: "HTML/XML", value: "markup" },
            { text: "JavaScript", value: "javascript" },
            { text: "CSS", value: "css" },
            { text: "PHP", value: "php" },
            { text: "Ruby", value: "ruby" },
            { text: "Python", value: "python" },
            { text: "Java", value: "java" },
            { text: "C", value: "c" },
            { text: "C#", value: "csharp" },
            { text: "C++", value: "cpp" },
          ],

          // 9. Optional: Insert a trailing paragraph if needed
          setup: (editor: Editor) => {
            // On init, ensure there's a blank paragraph at the end
            editor.on("init", () => {
              const raw = editor.getContent({ format: "raw" });
              if (!raw.match(/<p><br\s*\/?><\/p>\s*$/)) {
                editor.setContent(raw + "<p><br/></p>");
              }
            });
            // If user inserts a codesample, ensure there's a paragraph after it to type
            editor.on("ExecCommand", (e) => {
              if (e.command === "mceInsertContent") {
                // Delay a tick so insertion completes
                setTimeout(() => {
                  const updated = editor.getContent({ format: "raw" });
                  if (!updated.match(/<p><br\s*\/?><\/p>\s*$/)) {
                    editor.setContent(updated + "<p><br/></p>");
                  }
                }, 50);
              }
            });
          },
        }}
      />
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/PostMetadataSection.tsx -----
"use client";
import React from "react";
import CoverImageUploader from "./CoverImageUploader";
import TagInput from "../PostDetail/TagInput";

interface PostMetadataSectionProps {
  title: string;
  onTitleChange: (val: string) => void;
  tags: string[];
  onTagsChange: (val: string[]) => void;

  // Renamed props for cover image
  coverImageUrl: string;
  onCoverImageUrlChange: (url: string) => void;
  coverImageKey: string;
  onCoverImageKeyChange: (key: string) => void;
}

export default function PostMetadataSection({
  title,
  onTitleChange,
  tags,
  onTagsChange,
  coverImageUrl,
  onCoverImageUrlChange,
  coverImageKey,
  onCoverImageKeyChange,
}: PostMetadataSectionProps) {
  return (
    <div className="p-4 border-b border-slate-700">
      <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
        <div className="flex-1 space-y-4">
          <input
            type="text"
            placeholder="Post Title"
            value={title}
            onChange={(e) => onTitleChange(e.target.value)}
            className="w-full p-2 text-xl font-bold bg-slate-800 border border-slate-700 rounded focus:outline-none focus:border-teal-500"
          />
          <TagInput tags={tags} onChange={onTagsChange} />
        </div>
        <div className="w-full lg:w-1/3">
          <CoverImageUploader
            coverImageUrl={coverImageUrl}
            onCoverImageUrlChange={onCoverImageUrlChange}
            coverImageKey={coverImageKey}
            onCoverImageKeyChange={onCoverImageKeyChange}
          />
        </div>
      </div>
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/CoverImageUploader.tsx -----
"use client";

import React, { useState, DragEvent } from "react";
import { useUploadFile, UploadResult } from "@/hooks/s3/useUploadFile";
import { useAuth } from "react-oidc-context";
import Image from "next/image";

interface CoverImageUploaderProps {
  coverImageUrl: string;
  onCoverImageUrlChange: (url: string) => void;
  coverImageKey: string;
  onCoverImageKeyChange: (key: string) => void;
}

export default function CoverImageUploader({
  coverImageUrl,
  onCoverImageUrlChange,
  coverImageKey,
  onCoverImageKeyChange,
}: CoverImageUploaderProps) {
  const [uploading, setUploading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const { upload, loading, error } = useUploadFile();
  const auth = useAuth();

  async function handleFileUpload(file: File) {
    setUploading(true);
    setErrorMessage(null);
    try {
      const token = auth.user?.access_token;
      const result: UploadResult | undefined = await upload(file, "cover-images", token);
      if (!result) {
        throw new Error("No response from S3 service");
      }
      onCoverImageUrlChange(result.previewUrl);
      onCoverImageKeyChange(result.fileKey);
    } catch (err: any) {
      console.error("Upload error:", err);
      setErrorMessage(err.message || "Upload failed");
    } finally {
      setUploading(false);
    }
  }

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) handleFileUpload(file);
  };

  const handleDrop = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    const file = event.dataTransfer.files?.[0];
    if (file) handleFileUpload(file);
  };

  const handleDragOver = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
  };

  return (
    <div className="flex flex-col gap-3">
      <div
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        className="relative border-2 border-dashed border-slate-700 rounded-lg p-6 cursor-pointer hover:border-teal-500 transition-colors group"
      >
        <div className="absolute -top-3 left-1/2 -translate-x-1/2">
          <span className="px-3 py-1 bg-slate-800 border border-slate-700 rounded-full text-xs font-medium text-slate-300">
            Cover Image
          </span>
        </div>

        <div className="flex flex-col items-center justify-center min-h-[100px] gap-3">
          {coverImageUrl ? (
            <div className="relative w-full h-40 rounded-md overflow-hidden shadow-lg">
              <Image
                src={coverImageUrl}
                alt="Cover"
                fill
                className="object-cover rounded-md"
                unoptimized // Important for dynamic S3 URLs
              />
            </div>
          ) : (
            <div className="flex flex-col items-center gap-2 text-slate-400">
              <svg
                className="w-8 h-8 group-hover:text-teal-500 transition-colors"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                />
              </svg>
              <span className="text-sm">
                Drop an image here or click to upload
              </span>
            </div>
          )}
        </div>

        <input
          type="file"
          accept="image/*"
          onChange={handleFileChange}
          className="absolute inset-0 opacity-0 cursor-pointer"
        />
      </div>

      {(uploading || loading) && (
        <div className="flex items-center justify-center text-sm text-teal-300">
          <div className="animate-spin mr-2 h-4 w-4 border-2 border-teal-500 rounded-full border-t-transparent"></div>
          Uploading...
        </div>
      )}

      {(errorMessage || error) && (
        <div className="text-sm text-red-400 text-center">
          {errorMessage || error}
        </div>
      )}
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/TopUtilityBar.tsx -----
"use client";

import React from "react";

/**
 * TopUtilityBar
 * A sticky header showing:
 * - A link "Back to Dashboard"
 * - An auto-save indicator
 * - Preview button
 * - Publish button
 */
interface TopUtilityBarProps {
  autoSaveStatus: string;
  onPreview: () => void;
  onPublish: () => void;
}

const TopUtilityBar: React.FC<TopUtilityBarProps> = ({
  autoSaveStatus,
  onPreview,
  onPublish
}) => {
  return (
    <div className="sticky top-0 z-50 flex items-center justify-between p-3 bg-slate-700 border-slate-900 shadow-md">
      <div className="flex items-center gap-4">
        <span className="text-sm text-slate-400">{autoSaveStatus}</span>
      </div>
      <div className="flex items-center gap-4">
        <button
          onClick={onPreview}
          className="px-3 py-1 bg-slate-700 rounded hover:bg-slate-600 transition"
        >
          Preview Post
        </button>
        <button
          onClick={onPublish}
          className="px-4 py-1 bg-teal-500 rounded hover:bg-teal-400 transition font-bold"
        >
          Publish
        </button>
      </div>
    </div>
  );
};

export default TopUtilityBar;


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/AnimatedHeaderPost.tsx -----
"use client"

import Lottie from "lottie-react"
import explorerAnimation from "@/assets/animations/explorer-walking.json"
import { motion, useAnimationControls } from "framer-motion"
import { useLayoutEffect, useRef, useState } from "react"

export default function AnimatedHeaderPost() {
  const [showText, setShowText] = useState(false)
  const controls = useAnimationControls()
  const containerRef = useRef<HTMLDivElement>(null)

  useLayoutEffect(() => {
    let isMounted = true
    if (!containerRef.current) return

    const containerWidth = containerRef.current.offsetWidth
    const detectiveWidth = 64 
    const travelDistance = (containerWidth - detectiveWidth - 30) + containerWidth * 0.25;

    const runAnimation = async () => {
      if (!isMounted) return
      await controls.start({ x: travelDistance, scaleX: 1, transition: { duration: 3.2 } })
      await controls.start({ scaleX: -1, transition: { duration: 0.4 } })
      await controls.start({ x: 0, transition: { duration: 2.8 } })
      await controls.start({ scaleX: 1, transition: { duration: 0.4 } })

      if (!isMounted) return
      setShowText(true)
    }

    runAnimation()
    return () => { isMounted = false }
  }, [controls])

  return (
    <div
      ref={containerRef}
      className="relative bg-slate-900 border border-slate-700 mb-4 px-6 py-2 shadow-inner neon-glow-box"
    >
      {/* Detective Animation */}
      <motion.div
        className="absolute top-1/2 -translate-y-1/2 w-16 h-16 z-10 scale-[0.8]" // ⬅️ Smaller and tighter
        initial={{ x: 0, scaleX: 1 }}
        animate={controls}
      >
        <Lottie animationData={explorerAnimation} loop />
      </motion.div>

      {/* Text Content */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: showText ? 1 : 0 }}
        transition={{ duration: 0.6, delay: 0.2 }}
        className="relative z-0 flex flex-col md:flex-row md:items-end md:justify-between w-full pl-20"
      >
        <h1 className="text-xl md:text-2xl font-bold uppercase tracking-wider text-cyan-300">
          Explore Posts
        </h1>
        <p className="text-slate-400 text-xs md:text-sm md:text-right max-w-md mt-1 md:mt-0">
          Use filters and keywords to find the freshest, most relevant content.
        </p>
      </motion.div>

      <div className="absolute bottom-0 left-0 w-full h-px bg-slate-700" />
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/TagInput.tsx -----
"use client";

import React, { useState, KeyboardEvent } from "react";

interface TagInputProps {
  tags: string[];
  onChange: (tags: string[]) => void;
}

/**
 * Renders a row of chips for each tag.
 * On Enter or Comma, we add a new tag.
 * On chip 'x' click, remove that tag.
 */
export default function TagInput({ tags, onChange }: TagInputProps) {
  const [inputValue, setInputValue] = useState("");

  function handleKeyDown(e: KeyboardEvent<HTMLInputElement>) {
    if (e.key === "Enter" || e.key === ",") {
      e.preventDefault();
      const newTag = inputValue.trim();
      if (newTag && !tags.includes(newTag)) {
        onChange([...tags, newTag]);
      }
      setInputValue("");
    }
  }

  function removeTag(tag: string) {
    onChange(tags.filter((t) => t !== tag));
  }

  return (
    <div className="flex flex-col gap-2">
      {/* Tag Chips */}
      <div className="flex flex-wrap gap-2">
        {tags.map((tag) => (
          <div
            key={tag}
            className="flex items-center bg-teal-600 text-white px-2 py-1 rounded-full text-sm"
          >
            {tag}
            <button
              onClick={() => removeTag(tag)}
              className="ml-2 text-white hover:text-gray-200"
            >
              &times;
            </button>
          </div>
        ))}
      </div>

      {/* Input for new tag */}
      <input
        type="text"
        className="w-full p-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:border-teal-500"
        placeholder="Add tags, then press Enter..."
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyDown={handleKeyDown}
      />
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/PostMetadata.tsx -----
"use client"

import React from "react"
import Image from "next/image"
import { cn } from "@/lib/utils"
import { formatDistanceToNow } from "date-fns"

interface PostMetadataProps {
  author: {
    name: string
    avatarUrl: string
  }
  publishedAt: Date
  tags: string[];
  className?: string
}

export default function PostMetadata({
  author,
  publishedAt,
  tags,
  className,
}: PostMetadataProps) {
  return (
    <div className={cn("flex items-center gap-3 text-slate-400 text-sm", className)}>
      {/* Avatar */}
      <div className="w-8 h-8 rounded-full overflow-hidden">
        <Image
          src={author.avatarUrl}
          alt={author.name}
          width={32}
          height={32}
          className="object-cover"
        />
      </div>

      {/* Name, Time, Tag */}
      <div className="flex flex-wrap items-center gap-1.5">
        <span className="text-white font-medium">{author.name}</span>
        <span>•</span>
        <span>{formatDistanceToNow(publishedAt, { addSuffix: true })}</span>
        <span>•</span>
        <div className="flex gap-2 flex-wrap mt-1">
        {Array.isArray(tags) &&
          tags.map((tag) => (
            <span
              key={tag}
              className="bg-blue-600 text-white px-2 py-0.5 rounded-full text-xs font-medium"
            >
              {tag}
            </span>
        ))}
        </div>
      </div>
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/PostHeader.tsx -----
"use client";

import React from "react";
import Image from "next/image";
import PostMetadata from "./PostMetadata";

interface PostHeaderProps {
  title: string;
  coverImageUrl: string;
  author: {
    name: string;
    avatarUrl: string;
  };
  publishedAt: Date;
  tags: string[];
}

export default function PostHeader({
  title,
  coverImageUrl,
  author,
  publishedAt,
  tags,
}: PostHeaderProps) {
  // Check if the coverImageUrl is valid (e.g. non-empty and begins with "http" or "/")
  const isValidUrl = coverImageUrl && (coverImageUrl.startsWith("http") || coverImageUrl.startsWith("/"));

  // If not valid, use a fallback default image.
  const resolvedCoverImageUrl = isValidUrl ? coverImageUrl : "/default-cover.jpg";

  return (
    <div className="mb-6">
      {/* Banner image */}
      <div className="w-full h-48 md:h-56 lg:h-64 overflow-hidden rounded-md mb-6">
        <Image
          src={resolvedCoverImageUrl}
          alt="Post cover"
          width={1200}
          height={400}
          className="w-full h-full object-cover object-center"
        />
      </div>

      {/* Title */}
      <h1 className="text-3xl md:text-4xl font-bold text-white mb-4">
        {title}
      </h1>

      {/* Metadata */}
      <PostMetadata author={author} publishedAt={publishedAt} tags={tags} />
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/CommentSection.tsx -----
"use client"

import React, { useState } from "react"
import Comment from "./Comment"
import Image from "next/image"

interface CommentData {
  id: string
  author: {
    name: string
    avatarUrl: string
  }
  timestamp: string
  content: string
  likes: number
}

const mockComments: CommentData[] = [
  {
    id: "1",
    author: {
      name: "Carl Adams",
      avatarUrl: "/avatars/carl.png",
    },
    timestamp: "1 hour ago",
    content: "Great insights. Learned a lot!",
    likes: 2,
  },
  {
    id: "2",
    author: {
      name: "Jane Doe",
      avatarUrl: "/avatars/jane.png",
    },
    timestamp: "3 hours ago",
    content: "Thanks for breaking it down so clearly.",
    likes: 5,
  },
]

export default function CommentSection() {
  const [comments, setComments] = useState<CommentData[]>(mockComments)
  const [newComment, setNewComment] = useState("")

  const handlePost = () => {
    if (!newComment.trim()) return

    const newEntry: CommentData = {
      id: Date.now().toString(),
      author: {
        name: "You",
        avatarUrl: "/avatars/you.png",
      },
      timestamp: "Just now",
      content: newComment,
      likes: 0,
    }

    setComments((prev) => [newEntry, ...prev])
    setNewComment("")
  }

  return (
    <section className="mt-10">
      <h2 className="text-xl font-semibold mb-1">12 Comments</h2>
      <p className="text-slate-400 text-sm mb-6">Write a comment</p>

      {/* Comments List */}
      <div className="space-y-4">
        {comments.map((c) => (
          <Comment key={c.id} {...c} />
        ))}
      </div>

      <div className="mt-6 bg-slate-800 border border-slate-700 rounded-xl px-4 py-3 flex items-center gap-3">
        <Image
          src="/avatars/alex.png"
          alt="You"
          width={32}
          height={32}
          className="rounded-full object-cover"
        />
        <input
          type="text"
          placeholder="Add a comment..."
          value={newComment}
          onChange={(e) => setNewComment(e.target.value)}
          className="flex-1 bg-transparent text-white text-sm focus:outline-none placeholder:text-slate-400"
        />
        <button
          onClick={handlePost}
          className="text-sm text-blue-500 font-medium hover:underline"
        >
          Post
        </button>
      </div>
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/PostReactionPanel.tsx -----
"use client"

import React from "react"
import { ThumbsUp, MessageSquare, Share2, Bookmark } from "lucide-react"
import { motion } from "framer-motion"
import clsx from "clsx"

interface ReactionPanelProps {
  liked?: boolean
  bookmarked?: boolean
  onLike?: () => void
  onCommentClick?: () => void
  onShare?: () => void
  onBookmark?: () => void
}

const iconButtonStyle = (active = false) =>
  clsx(
    "w-10 h-10 flex items-center justify-center rounded-md transition-colors border border-slate-700 hover:bg-slate-700",
    active ? "bg-blue-600 text-white" : "bg-slate-800 text-slate-300"
  )

export default function PostReactionPanel({
  liked,
  bookmarked,
  onLike,
  onCommentClick,
  onShare,
  onBookmark,
}: ReactionPanelProps) {
  return (
    <motion.div
      initial={{ opacity: 0, x: 30 }}
      animate={{ opacity: 1, x: 0 }}
      transition={{ duration: 0.4, delay: 0.2 }}
      className="hidden lg:flex flex-col gap-4 sticky top-28 ml-6"
    >
      <button onClick={onLike} className={iconButtonStyle(liked)}>
        <ThumbsUp size={18} />
      </button>

      <button onClick={onCommentClick} className={iconButtonStyle()}>
        <MessageSquare size={18} />
      </button>

      <button onClick={onShare} className={iconButtonStyle()}>
        <Share2 size={18} />
      </button>

      <button onClick={onBookmark} className={iconButtonStyle(bookmarked)}>
        <Bookmark size={18} />
      </button>
    </motion.div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/Comment.tsx -----
"use client"

import React from "react"
import Image from "next/image"
import { MoreVertical } from "lucide-react"

interface CommentProps {
  author: {
    name: string
    avatarUrl: string
  }
  timestamp: string
  content: string
  likes: number
}

export default function Comment({ author, timestamp, content, likes }: CommentProps) {
  return (
    <div className="flex items-start gap-4 py-4 border-b border-slate-700">
      {/* Avatar */}
      <div className="w-10 h-10 flex-shrink-0 rounded-full overflow-hidden">
        <Image
          src={author.avatarUrl}
          alt={author.name}
          width={40}
          height={40}
          className="rounded-full object-cover"
        />
      </div>

      {/* Main content */}
      <div className="flex-1">
        {/* Top Row */}
        <div className="flex justify-between items-center mb-1">
          <div className="flex items-center gap-2 text-sm text-slate-300">
            <span className="font-semibold text-white">{author.name}</span>
            <span className="text-slate-500">•</span>
            <span>{timestamp}</span>
          </div>
          <MoreVertical className="w-4 h-4 text-slate-500 cursor-pointer hover:text-slate-300" />
        </div>

        {/* Comment Content */}
        <p className="text-slate-100 text-sm mb-2">{content}</p>

        {/* Bottom Row */}
        <div className="flex items-center justify-between text-sm text-slate-400">
          <button className="hover:underline text-sm">Reply</button>
          <span>{likes}</span>
        </div>
      </div>
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/PostDetail.tsx -----
"use client";

import React from "react";
import PostHeader from "./PostHeader";
import PostReactionPanel from "./PostReactionPanel";
import CommentSection from "./CommentSection";

interface PostDetailProps {
  post: {
    title: string;
    coverImageUrl: string;
    author: {
      name: string;
      avatarUrl: string;
    };
    publishedAt: Date;
    tags: string[];
    content: string;
  };
}

export default function PostDetail({ post }: PostDetailProps) {
  return (
    <main className="bg-slate-900 text-white min-h-screen pt-6 pb-20">
      <section className="max-w-6xl mx-auto px-4 md:px-8 flex gap-10">
        {/* Left Sticky Reaction Panel */}
        <div className="hidden lg:block">
          <PostReactionPanel />
        </div>

        {/* Main Content */}
        <div className="flex-1">
          {/* Header (Banner, Title, Meta) */}
          <PostHeader
            title={post.title}
            coverImageUrl={post.coverImageUrl}
            author={post.author}
            publishedAt={post.publishedAt}
            tags={post.tags}
          />

          {/* Body Content rendered as HTML */}
          <article
            className="text-slate-300 leading-relaxed space-y-6"
            dangerouslySetInnerHTML={{ __html: post.content }}
          />

          {/* Comment Section */}
          <CommentSection />
        </div>
      </section>
    </main>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/HeaderRecentPosts.tsx -----
"use client"

import React from "react"
import Lottie from "lottie-react"
import newspaperAnimation from "@/assets/animations/recent-newspaper.json"
import { motion } from "framer-motion"

export default function HeaderRecentPosts() {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="mb-6 flex flex-col md:flex-row md:items-end md:justify-between gap-4"
    >
      {/* Icon + Title */}
      <div className="flex items-center gap-4">
        <motion.div
          whileHover={{ scale: 1.2 }}
          transition={{ type: "spring", stiffness: 300 }}
          className="w-14 h-14 md:w-16 md:h-16"
        >
          <Lottie animationData={newspaperAnimation} loop autoplay />
        </motion.div>
        <h1 className="text-3xl md:text-4xl font-bold">Recent Posts</h1>
      </div>

      {/* Description */}
      <p className="text-slate-400 text-sm md:text-base md:text-right max-w-xl">
        Catch up on what the community is talking about!
      </p>
    </motion.div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCard.tsx -----
"use client"

import React from "react"
import { motion } from "framer-motion"
import { ThumbsUp, MessageCircle } from "lucide-react"
import Image from "next/image"
import DOMPurify from "dompurify"

export interface PostCardProps {
  id: string
  title: string
  description: string
  author: string
  timestamp: string
  tags?: string[]
  imageUrl?: string
  reactionCount?: number
  commentCount?: number
  onClick?: (postId: string) => void
}

export default function PostCard({
  id,
  title,
  description,
  author,
  timestamp,
  tags = [],
  imageUrl,
  reactionCount = 0,
  commentCount = 0,
  onClick,
}: PostCardProps) {
  const safeDescription = DOMPurify.sanitize(description);
  return (
    <motion.div
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={() => onClick?.(id)}
      className="relative h-64 w-full rounded-xl overflow-hidden shadow-md bg-slate-800 cursor-pointer"
    >
      {/* Background image (blurred) */}
      {imageUrl && (
        <Image
          src={imageUrl}
          alt={title}
          fill
          className="object-cover blur-sm opacity-60"
          sizes="(max-width: 768px) 100vw,
                 (max-width: 1200px) 50vw,
                 33vw"
        />
      )}

      {/* Overlay content */}
      <div className="relative z-10 flex flex-col justify-end h-full p-4">
        {/* Tag chips */}
        <div className="flex flex-wrap gap-2 mb-2">
          {tags.map((tag) => (
            <span
              key={tag}
              className="bg-blue-600 text-white text-xs font-medium px-2 py-1 rounded"
            >
              {tag}
            </span>
          ))}
        </div>

        {/* Title + Description */}
        <h3 className="text-white text-lg font-semibold line-clamp-1">{title}</h3>
        <p className="text-gray-300 text-sm line-clamp-2 mt-1">
          <span dangerouslySetInnerHTML={{ __html: safeDescription }} />
        </p>

        {/* Footer row: author, time, reactions, comments */}
        <div className="flex justify-between items-center mt-3 text-xs text-gray-400 bg-slate-950 -mx-4 -mb-4 p-3 border-t border-slate-800">
          <span>
            By {author} · {timestamp}
          </span>
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-1">
              <ThumbsUp className="w-4 h-4 text-gray-400" />
              <span>{reactionCount}</span>
            </div>
            <div className="flex items-center gap-1">
              <MessageCircle className="w-4 h-4 text-gray-400" />
              <span>{commentCount}</span>
            </div>
          </div>
        </div>
      </div>
    </motion.div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/RecentPosts.tsx -----
"use client"

import React from "react"
import PostCard, { PostCardProps } from "./PostCard"
import { useRouter } from "next/navigation"
import { motion } from "framer-motion"
import HeaderRecentPosts from "./HeaderRecentPosts"

interface RecentPostsProps {
  posts: PostCardProps[]
  onLoadMore?: () => void
  hasMore?: boolean
}

const containerVariants = {
  hidden: {},
  visible: {
    transition: {
      staggerChildren: 0.1,
    },
  },
}

const cardVariants = {
  hidden: { opacity: 0, y: 30 },
  visible: { opacity: 1, y: 0 },
}

export default function RecentPosts({
  posts,
  onLoadMore,
  hasMore = false,
}: RecentPostsProps) {
  const router = useRouter()

  return (
    // Static main container so it fits nicely under the navbar
    <main className="bg-slate-900 text-white pt-8 pb-16">
      <section className="max-w-7xl mx-auto px-4 md:px-8">
      <HeaderRecentPosts />


        {/* Posts Grid with staggered animation on each card */}
        <motion.div
          className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6"
          variants={containerVariants}
          initial="hidden"
          animate="visible"
        >
          {posts.map((post) => (
            <motion.div key={post.id} variants={cardVariants}>
              <PostCard
                {...post}
                onClick={(postId) => router.push(`/posts/${postId}`)}
              />
            </motion.div>
          ))}
        </motion.div>

        {/* Load More Button with a subtle button animation */}
        {hasMore && (
          <div className="flex justify-center mt-10">
            <motion.button
              onClick={onLoadMore}
              whileHover={{ scale: 1.03 }}
              whileTap={{ scale: 0.97 }}
              className="bg-slate-700 hover:bg-slate-600 text-white rounded-xl py-2 px-6 font-medium transition"
            >
              Load More
            </motion.button>
          </div>
        )}
      </section>
    </main>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/ExplorePostsContent.tsx -----
"use client";

import React, { useEffect, useState } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import dynamic from "next/dynamic";
import NoPostsHolder from "@/components/posts/NoPostsHolder";
import PostCard from "@/components/posts/PostCard";
import AnimatedHeaderPost from "@/components/posts/AnimatedHeaderPost";
import { useAuth } from "react-oidc-context";
import { explorePosts, PostDTO } from "@/services/postService";
import Fallback from "@/components/Fallback/Fallback";

export interface FilterState {
  keyword: string;
  tag: string;
  sort: "recent" | "popular" | "mostLiked";
}

const ExplorePostsFilter = dynamic(
  () => import("@/components/posts/ExplorePostsFilter.client"),
  { ssr: false }
);

export default function ExplorePostsContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const initialTag = searchParams.get("tag") || "";
  const auth = useAuth();

  const [filters, setFilters] = useState<FilterState>({
    keyword: "",
    tag: initialTag,
    sort: "recent",
  });

  const [posts, setPosts] = useState<PostDTO[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      setLoading(true);
      try {
        const token = auth.user?.access_token;
        const page = 0;
        const size = 30;
        const tagList = filters.tag ? [filters.tag] : [];
        const dataPage = await explorePosts(filters.keyword, tagList, filters.sort, page, size, token);
        setPosts(dataPage.content || []);
      } catch (err: any) {
        setError(err.message || "Failed to load posts.");
      } finally {
        setLoading(false);
      }
    };

    if (auth.user) {
      fetchPosts();
    }
  }, [filters, auth.user]);

  if (loading) return <Fallback message="Loading your awesome posts..." />;
  if (error) return <Fallback message={`❌ ${error}`} />;

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <AnimatedHeaderPost />
      <ExplorePostsFilter filters={filters} setFilters={setFilters} />
      {posts.length > 0 ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mt-6">
          {posts.map((post) => (
            <PostCard
              key={post.id}
              id={post.id!}
              title={post.title}
              description={post.content}
              author={post.authorId ? `User ${post.authorId.substring(0, 6)}` : "Unknown Author"}
              timestamp={post.createdAt ? new Date(post.createdAt).toLocaleDateString() : ""}
              tags={post.tags || []}
              imageUrl={post.bannerImageUrl || "/default-cover.jpg"}
              reactionCount={(post.likeCount || 0) + (post.heartCount || 0)}
              commentCount={0}
              onClick={() => router.push(`/posts/${post.id}`)}
            />
          ))}
        </div>
      ) : (
        <div className="mt-10">
          <NoPostsHolder />
        </div>
      )}
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/ExplorePostsFilter.client.tsx -----
"use client";

import React, { useState } from "react";
import { FilterState } from "./ExplorePostsFilter";
import Lottie from "lottie-react";
import searchLottie from "@/assets/animations/searchLottie.json";
import CyberpunkSelect from "@/components/ui/CyberpunkSelect";

interface ExplorePostsFilterProps {
  filters: FilterState;
  setFilters: React.Dispatch<React.SetStateAction<FilterState>>;
}

const ExplorePostsFilter: React.FC<ExplorePostsFilterProps> = ({ filters, setFilters }) => {
  const [localFilters, setLocalFilters] = useState(filters);

  const updateLocalFilter = (field: keyof FilterState, value: string) => {
    setLocalFilters((prev) => ({ ...prev, [field]: value }));
  };

  const handleSearch = () => {
    setFilters(localFilters);
  };

  return (
    <div className="mb-6 px-4 md:px-0 font-mono">
      <div className="grid md:grid-cols-[1fr_1fr_1fr_auto] border border-slate-700 divide-x divide-slate-700 overflow-hidden shadow-md">
        {/* Keyword */}
        <div className="bg-slate-900 p-2 flex items-center">
          <input
            type="text"
            placeholder="Search posts..."
            value={localFilters.keyword}
            onChange={(e) => updateLocalFilter("keyword", e.target.value)}
            className="w-full bg-transparent text-slate-200 text-sm border-none px-1 py-1.5 placeholder-slate-500 focus:outline-none focus:ring-0"
          />
        </div>

        {/* Tag */}
        <div className="bg-slate-900 p-2 flex items-center">
          <input
            type="text"
            placeholder="Filter by tag..."
            value={localFilters.tag}
            onChange={(e) => updateLocalFilter("tag", e.target.value)}
            className="w-full bg-transparent text-slate-200 text-sm border-none px-1 py-1.5 placeholder-slate-500 focus:outline-none focus:ring-0"
          />
        </div>

        {/* Sort */}
        <div className="bg-slate-900 p-2 flex items-center">
          <CyberpunkSelect
            value={localFilters.sort}
            onChange={(val) => updateLocalFilter("sort", val)}
          />
        </div>

        {/* Search Button */}
        <div className="bg-slate-900 p-2 flex items-center justify-center hover:bg-slate-800 transition-colors">
          <button
            onClick={handleSearch}
            className="w-full h-full flex items-center justify-center hover:scale-105 transition-transform duration-150"
          >
            <Lottie animationData={searchLottie} loop style={{ width: 36, height: 36 }} />
          </button>
        </div>
      </div>
    </div>
  );
};

export default ExplorePostsFilter;


----- /home/zakaria/zBlog/zblog-frontend/src/context/PostDraftContext.tsx -----
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";

interface PostDraft {
  title: string;
  tags: string[];
  coverImageUrl: string;  // ephemeral or public URL for immediate preview
  coverImageKey: string;  // the S3 key stored for back-end (bannerImageKey)
  content: string;
}

interface PostDraftContextValue {
  draft: PostDraft;
  setDraft: React.Dispatch<React.SetStateAction<PostDraft>>;
  resetDraft: () => void;
}

const defaultDraft: PostDraft = {
  title: "",
  tags: [],
  coverImageUrl: "",
  coverImageKey: "",
  content: "",
};

const PostDraftContext = createContext<PostDraftContextValue | undefined>(undefined);

export function PostDraftProvider({ children }: { children: ReactNode }) {
  const [draft, setDraft] = useState<PostDraft>(defaultDraft);

  function resetDraft() {
    setDraft(defaultDraft);
  }

  return (
    <PostDraftContext.Provider value={{ draft, setDraft, resetDraft }}>
      {children}
    </PostDraftContext.Provider>
  );
}

export function usePostDraft() {
  const context = useContext(PostDraftContext);
  if (!context) {
    throw new Error("usePostDraft must be used within a PostDraftProvider");
  }
  return context;
}


----- /home/zakaria/zBlog/zblog-frontend/src/providers/CognitoProvider.tsx -----
"use client"

import { AuthProvider } from "react-oidc-context";
import { cognitoConfig } from "@/lib/cognitoConfig";

export default function CognitoProvider({ children }: { children: React.ReactNode }) {
  return <AuthProvider {...cognitoConfig}>{children}</AuthProvider>;
}


----- /home/zakaria/zBlog/zblog-frontend/src/services/userService.ts -----
import axios, { AxiosError } from 'axios';

/**
 * Environment-based URL for the user-core service. Adjust as needed.
 * E.g. "https://api.example.com/user"
 */
const userCoreBaseURL =
  process.env.NEXT_PUBLIC_USER_CORE_URL ?? 'http://localhost:8080/user';

// ------------------
// Type Definitions
// ------------------

/** Matches Java: InitUserRequest */
export interface InitUserRequest {
  sub: string;
  username: string;
  email: string;
}

/** Represents the response from initUser (Map<String,Object>) */
export interface InitUserResponse {
  status: string;
  message: string;
  userId?: string;
}

/** Matches Java: UserProfileDTO */
export interface UserProfileDTO {
  username: string;
  displayName?: string;
  bio?: string;
  profileImageFileId?: string;
  profileImageUrl?: string;
  createdAt?: string;  // Instant -> string in JSON
  updatedAt?: string;  // Instant -> string in JSON
}

/** Matches Java: BookmarkDTO */
export interface BookmarkDTO {
  id: string;         // UUID -> string
  postId: string;     // UUID -> string
  createdAt: string;  // Instant -> string
}

// ---------------
// Utility Functions
// ---------------

/**
 * initUser: POST /user/internal/init-user
 * 
 * @param payload  Body of type InitUserRequest
 * @param providedSecret  Value for "X-Internal-Secret" header
 * @param authToken  Optional Bearer token
 */
export async function initUser(
  payload: InitUserRequest,
  providedSecret: string,
  authToken?: string
): Promise<InitUserResponse> {
  try {
    const url = `${userCoreBaseURL}/internal/init-user`;
    const res = await axios.post<InitUserResponse>(url, payload, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        'X-Internal-Secret': providedSecret,
        'Content-Type': 'application/json',
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * healthCheck: GET /user/health
 */
export async function getUserHealth(): Promise<string> {
  try {
    const url = `${userCoreBaseURL}/health`;
    const res = await axios.get<string>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * followUser: POST /user/api/follow/{targetUserId}
 */
export async function followUser(
  targetUserId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${userCoreBaseURL}/api/follow/${targetUserId}`;
    await axios.post<void>(
      url,
      {},
      {
        headers: {
          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        },
      }
    );
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * unfollowUser: DELETE /user/api/follow/{targetUserId}
 */
export async function unfollowUser(
  targetUserId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${userCoreBaseURL}/api/follow/${targetUserId}`;
    await axios.delete<void>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * createBookmark: POST /user/api/bookmarks/{postId}
 * returns BookmarkDTO
 */
export async function createBookmark(
  postId: string,
  authToken?: string
): Promise<BookmarkDTO> {
  try {
    const url = `${userCoreBaseURL}/api/bookmarks/${postId}`;
    const res = await axios.post<BookmarkDTO>(
      url,
      {},
      {
        headers: {
          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        },
      }
    );
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * removeBookmark: DELETE /user/api/bookmarks/{postId}
 */
export async function removeBookmark(
  postId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${userCoreBaseURL}/api/bookmarks/${postId}`;
    await axios.delete<void>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * listBookmarks: GET /user/api/bookmarks
 * 
 * Returns a "Page<BookmarkDTO>". For simplicity, we'll define a custom Paginated type.
 */
export interface Page<T> {
  content: T[];
  empty: boolean;
  first: boolean;
  last: boolean;
  number: number;
  size: number;
  totalElements: number;
  totalPages: number;
}

export async function listBookmarks(
  page: number,
  size: number,
  authToken?: string
): Promise<Page<BookmarkDTO>> {
  try {
    const url = `${userCoreBaseURL}/api/bookmarks?page=${page}&size=${size}`;
    const res = await axios.get<Page<BookmarkDTO>>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getUserProfile: GET /user/api/users/{userId}
 */
export async function getUserProfile(
  userId: string
): Promise<UserProfileDTO> {
  try {
    const url = `${userCoreBaseURL}/api/users/${userId}`;
    const res = await axios.get<UserProfileDTO>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getMyProfile: GET /user/api/users/me
 */
export async function getMyProfile(authToken?: string): Promise<UserProfileDTO> {
  try {
    const url = `${userCoreBaseURL}/api/users/me`;
    const res = await axios.get<UserProfileDTO>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * updateMyProfile: PUT /user/api/users/me
 */
export async function updateMyProfile(
  profile: UserProfileDTO,
  authToken?: string
): Promise<UserProfileDTO> {
  try {
    const url = `${userCoreBaseURL}/api/users/me`;
    const res = await axios.put<UserProfileDTO>(url, profile, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// ---------------
// Error Handling
// ---------------
function handleAxiosError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const err = error as AxiosError;
    throw new Error(err.response?.data?.toString() || err.message);
  }
  throw error;
}


----- /home/zakaria/zBlog/zblog-frontend/src/services/postService.ts -----
import axios, { AxiosError } from 'axios';

const postCoreBaseURL =
  (process.env.NEXT_PUBLIC_POST_CORE_URL ?? 'http://localhost:8081/post').replace(/\/+$/, '');

  export interface PostDTO {
    id?: string;
    authorId?: string;
    title: string;
    content: string;
    published?: boolean;
    viewCount?: number;
    likeCount?: number;
    heartCount?: number;
    bookmarkCount?: number;
    bannerImageKey?: string;
    bannerImageUrl?: string;
    createdAt?: string;
    updatedAt?: string;
    scheduledPublishAt?: string;
    tags?: string[];
  }

// The Page<T> interface can be reused from userService (or define your own).
import { Page } from './userService';

/**
 * getPostHealth: GET /post/health
 */
export async function getPostHealth(): Promise<string> {
  try {
    const url = `${postCoreBaseURL}/health`;
    const res = await axios.get<string>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * Calls the new explore endpoint.
 */
export async function explorePosts(
  keywords: string,
  tags: string[],
  sort: "recent" | "popular" | "mostLiked",
  page: number,
  size: number,
  authToken?: string
): Promise<Page<PostDTO>> {
  const params = new URLSearchParams();
  if (keywords) params.append("keywords", keywords);
  if (tags.length > 0) params.append("tags", tags.join(","));
  params.append("sort", sort);
  params.append("page", page.toString());
  params.append("size", size.toString());

  const url = `${process.env.NEXT_PUBLIC_POST_CORE_URL?.replace(/\/+$/, "")}/api/posts/explore?${params.toString()}`;
  const res = await axios.get<Page<PostDTO>>(url, {
    headers: { ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}) },
  });
  return res.data;
}

// CREATE: POST /post/api/posts
export async function createPost(
  postDTO: PostDTO,
  authToken?: string
): Promise<PostDTO> {
  try {
    const url = `${postCoreBaseURL}/api/posts`;
    const res = await axios.post<PostDTO>(url, postDTO, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

export async function getPost(postId: string, authToken?: string): Promise<PostDTO> {
  const url = `${postCoreBaseURL}/api/posts/${postId}`;
  const res = await axios.get<PostDTO>(url, {
    headers: { ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}) },
  });
  return res.data;
}

// UPDATE: PUT /post/api/posts/{postId}
export async function updatePost(
  postId: string,
  postDTO: PostDTO,
  authToken?: string
): Promise<PostDTO> {
  try {
    const url = `${postCoreBaseURL}/api/posts/${postId}`;
    const res = await axios.put<PostDTO>(url, postDTO, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// DELETE: DELETE /post/api/posts/{postId}
export async function deletePost(
  postId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${postCoreBaseURL}/api/posts/${postId}`;
    await axios.delete<void>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
  } catch (error) {
    handleAxiosError(error);
  }
}

// LIST/PAGINATION: GET /post/api/posts?publishedOnly={true|false}&page=X&size=Y
export async function getAllPosts(
  publishedOnly: boolean,
  page: number,
  size: number,
  authToken?: string
): Promise<Page<PostDTO>> {
  const url = `${postCoreBaseURL}/api/posts?publishedOnly=${publishedOnly}&page=${page}&size=${size}`;
  const res = await axios.get<Page<PostDTO>>(url, {
    headers: { ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}) },
  });
  return res.data;
}

// SEARCH: GET /post/api/posts/search?keyword=...&publishedOnly=...
export async function searchPosts(
  keyword: string,
  publishedOnly: boolean,
  page: number,
  size: number,
  authToken?: string
): Promise<Page<PostDTO>> {
  const url = `${postCoreBaseURL}/api/posts/search?keyword=${encodeURIComponent(
    keyword
  )}&publishedOnly=${publishedOnly}&page=${page}&size=${size}`;
  const res = await axios.get<Page<PostDTO>>(url, {
    headers: { ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}) },
  });
  return res.data;
}

// LIST BY AUTHOR: GET /post/api/posts/by-author/{authorId}?publishedOnly=...
export async function getPostsByAuthor(
  authorId: string,
  publishedOnly: boolean,
  page: number,
  size: number
): Promise<Page<PostDTO>> {
  try {
    const url = `${postCoreBaseURL}/api/posts/by-author/${authorId}?publishedOnly=${publishedOnly}&page=${page}&size=${size}`;
    const res = await axios.get<Page<PostDTO>>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// INCREMENT VIEW COUNT: PATCH /post/api/posts/{postId}/view
export async function incrementView(
  postId: string
): Promise<PostDTO> {
  try {
    const url = `${postCoreBaseURL}/api/posts/${postId}/view`;
    const res = await axios.patch<PostDTO>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// REACT: PATCH /post/api/posts/{postId}/react?type=like|heart|...
export async function react(
  postId: string,
  reactionType: string,
  authToken?: string
): Promise<PostDTO> {
  try {
    const url = `${postCoreBaseURL}/api/posts/${postId}/react?type=${reactionType}`;
    const res = await axios.patch<PostDTO>(
      url,
      {},
      {
        headers: {
          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        },
      }
    );
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// GET ALL TAGS: GET /post/api/tags
export async function getAllTags(): Promise<string[]> {
  try {
    const url = `${postCoreBaseURL}/api/tags`;
    const res = await axios.get<string[]>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// ---------------
// Error Handling
// ---------------
function handleAxiosError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const err = error as AxiosError;
    throw new Error(err.response?.data?.toString() || err.message);
  }
  throw error;
}


----- /home/zakaria/zBlog/zblog-frontend/src/services/s3Service.ts -----
import axios, { AxiosError } from 'axios';

const s3CoreBaseURL =
  process.env.NEXT_PUBLIC_S3_CORE_URL ?? 'http://localhost:8083/s3';

// Matches Java: S3FileMetadata
export interface S3FileMetadata {
  key: string;
  size: number;
  mimeType: string;
  uploadTimestamp: string;  // Instant -> string
  url: string;              // URL -> string
}

// GET /s3/health
export async function getS3Health(): Promise<string> {
  try {
    const url = `${s3CoreBaseURL}/health`;
    const res = await axios.get<string>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * uploadFile: POST /s3/files
 * 
 * @param file  the File/Blob
 * @param directory optional string for "directory" param (default "posts")
 * 
 * NOTE: In a browser, you’d typically need a FormData
 */
export async function uploadFile(
  file: File,
  directory = 'posts',
  authToken?: string
): Promise<S3FileMetadata> {
  const s3CoreBaseURL = (() => {
    const url = process.env.NEXT_PUBLIC_S3_CORE_URL;
    if (!url) throw new Error("Missing NEXT_PUBLIC_S3_CORE_URL");
    return url.replace(/\/+$/, ''); // strip trailing slash
  })();
  
  try {
    const url = `${s3CoreBaseURL}/files`;
    const formData = new FormData();
    formData.append('file', file);
    formData.append('directory', directory);

    const res = await axios.post<S3FileMetadata>(url, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getFileUrl: GET /s3/files/**?public=false
 * 
 * Java code slices the path after /internal/files/, 
 * but from a client standpoint, you’d typically do something like:
 * GET /s3/files/actualKey?public=false
 */
export async function getFileUrl(
  fileKey: string,
  isPublic = false,
  authToken?: string
): Promise<string> {
  try {
    const url = `${s3CoreBaseURL}/files/${fileKey}?public=${isPublic}`;
    const res = await axios.get<string>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getPresignedUploadUrl: GET /s3/files/{fileKey}/presign-upload
 */
export async function getPresignedUploadUrl(
  fileKey: string,
  authToken?: string
): Promise<string> {
  try {
    const url = `${s3CoreBaseURL}/files/${fileKey}/presign-upload`;
    const res = await axios.get<string>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * deleteFile: DELETE /s3/files/** 
 */
export async function deleteFile(fileKey: string, authToken?: string): Promise<string> {
  try {
    const url = `${s3CoreBaseURL}/files/${fileKey}`;
    const res = await axios.delete<string>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * listFiles: GET /s3/files?prefix=someFolder/
 */
export async function listFiles(prefix: string, authToken?: string): Promise<S3FileMetadata[]> {
  try {
    const url = `${s3CoreBaseURL}/files?prefix=${encodeURIComponent(prefix)}`;
    const res = await axios.get<S3FileMetadata[]>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// ---------------
// Error Handling
// ---------------
function handleAxiosError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const err = error as AxiosError;
    throw new Error(err.response?.data?.toString() || err.message);
  }
  throw error;
}


----- /home/zakaria/zBlog/zblog-frontend/src/services/commentService.ts -----
import axios, { AxiosError } from 'axios';
import { Page } from '@/services/userService'; // or define again

const commentCoreBaseURL =
  process.env.NEXT_PUBLIC_COMMENT_CORE_URL ?? 'http://localhost:8082/comment';

// From your DTOs:

export interface CommentCreateRequest {
  postId: string;         // UUID
  parentId?: string;      // UUID
  content: string;
  attachmentFileId?: string;
}

export interface CommentUpdateRequest {
  id: string; // UUID
  content: string;
  attachmentFileId?: string;
}

export interface CommentResponseDTO {
  id: string;        // UUID
  postId: string;    // UUID
  authorId: string;
  content: string;
  createdAt: string; // Instant -> string
  updatedAt: string; // Instant -> string
  parentId?: string; // UUID
  likeCount: number;
  laughCount: number;
  sadCount: number;
  insightfulCount: number;
  replies?: CommentResponseDTO[];
  attachmentFileId?: string;
  attachmentFileUrl?: string;
}

/**
 * commentHealthCheck: GET /comment/health
 */
export async function getCommentHealth(): Promise<string> {
  try {
    const url = `${commentCoreBaseURL}/health`;
    const res = await axios.get<string>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * createComment: POST /comment/api/comments
 */
export async function createComment(
  data: CommentCreateRequest,
  authToken?: string
): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments`;
    const res = await axios.post<CommentResponseDTO>(url, data, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * updateComment: PUT /comment/api/comments/{commentId}
 */
export async function updateComment(
  commentId: string,
  data: CommentUpdateRequest,
  authToken?: string
): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}`;
    const res = await axios.put<CommentResponseDTO>(url, data, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * deleteComment: DELETE /comment/api/comments/{commentId}
 */
export async function deleteComment(
  commentId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}`;
    await axios.delete<void>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getTopLevelComments: GET /comment/api/comments/post/{postId}?page=X&size=Y
 */
export async function getTopLevelComments(
  postId: string,
  page: number,
  size: number
): Promise<Page<CommentResponseDTO>> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/post/${postId}?page=${page}&size=${size}`;
    const res = await axios.get<Page<CommentResponseDTO>>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getComment: GET /comment/api/comments/{commentId}
 */
export async function getComment(commentId: string): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}`;
    const res = await axios.get<CommentResponseDTO>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getCommentThread: GET /comment/api/comments/{commentId}/thread
 */
export async function getCommentThread(
  commentId: string
): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}/thread`;
    const res = await axios.get<CommentResponseDTO>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * toggleReaction: PATCH /comment/api/comments/{commentId}/react?type=like|laugh|sad|insightful
 */
export async function toggleReaction(
  commentId: string,
  reactionType: string,
  authToken?: string
): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}/react?type=${reactionType}`;
    const res = await axios.patch<CommentResponseDTO>(
      url,
      {},
      {
        headers: {
          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        },
      }
    );
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// ---------------
// Error Handling
// ---------------
function handleAxiosError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const err = error as AxiosError;
    throw new Error(err.response?.data?.toString() || err.message);
  }
  throw error;
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/comment/useCreateComment.ts -----
import { useState } from 'react';
import {
  createComment,
  CommentCreateRequest,
  CommentResponseDTO,
} from '@/services/commentService';

interface UseCreateComment {
  create: (req: CommentCreateRequest, token?: string) => Promise<CommentResponseDTO | undefined>;
  loading: boolean;
  error?: string;
}

export function useCreateComment(): UseCreateComment {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  async function create(
    req: CommentCreateRequest,
    token?: string
  ): Promise<CommentResponseDTO | undefined> {
    try {
      setLoading(true);
      setError(undefined);
      const result = await createComment(req, token);
      return result;
    } catch (err: any) {
      setError(err.message || 'Error creating comment');
      return undefined;
    } finally {
      setLoading(false);
    }
  }

  return { create, loading, error };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/post/useCreatePost.ts -----
"use client";

import { useState } from "react";
import { createPost, PostDTO } from "@/services/postService";

/**
 * A custom hook to create a post via post-core service.
 */
export function useCreatePost() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  /**
   * create: Calls the createPost() service method. 
   * Pass `authToken` (e.g. from Cognito).
   */
  async function create(post: PostDTO, authToken?: string) {
    try {
      setLoading(true);
      setError(null);

      const newPost = await createPost(post, authToken);
      return newPost;
    } catch (err: any) {
      setError(err.message || "Failed to create post");
      return null;
    } finally {
      setLoading(false);
    }
  }

  return {
    create,
    loading,
    error,
  };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/post/useGetPost.ts -----
import { useEffect, useState } from 'react';
import { getPost, PostDTO } from '@/services/postService';

interface UseGetPostReturn {
  data?: PostDTO;
  error?: string;
  loading: boolean;
  refetch: () => void;
}

export function useGetPost(postId: string, authToken?: string): UseGetPostReturn {
  const [data, setData] = useState<PostDTO | undefined>(undefined);
  const [error, setError] = useState<string | undefined>(undefined);
  const [loading, setLoading] = useState<boolean>(true);

  const fetchPost = async () => {
    try {
      setLoading(true);
      const result = await getPost(postId, authToken);
      setData(result);
      setError(undefined);
    } catch (err: any) {
      setError(err.message || 'Error fetching post');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (postId) {
      fetchPost();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [postId]);

  return {
    data,
    error,
    loading,
    refetch: fetchPost,
  };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/user/useInitUser.ts -----
import { useState } from 'react';
import { initUser, InitUserRequest, InitUserResponse } from '@/services/userService';

interface UseInitUser {
  init: (payload: InitUserRequest, secret: string, token?: string) => Promise<InitUserResponse | undefined>;
  loading: boolean;
  error: string | null;
}

export function useInitUser(): UseInitUser {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function init(
    payload: InitUserRequest,
    secret: string,
    token?: string
  ): Promise<InitUserResponse | undefined> {
    try {
      setLoading(true);
      setError(null);
      const response = await initUser(payload, secret, token);
      return response;
    } catch (err: any) {
      setError(err.message || 'Failed to init user');
      return undefined;
    } finally {
      setLoading(false);
    }
  }

  return { init, loading, error };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/s3/useUploadFile.ts -----
import { useState } from 'react';
import { uploadFile, S3FileMetadata } from '@/services/s3Service';

export interface UploadResult {
  previewUrl: string;
  fileKey: string;
}

interface UseUploadFile {
  upload: (file: File, directory?: string, token?: string) => Promise<UploadResult | undefined>;
  loading: boolean;
  error?: string;
}

export function useUploadFile(): UseUploadFile {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  async function upload(
    file: File,
    directory?: string,
    token?: string
  ): Promise<UploadResult | undefined> {
    try {
      setLoading(true);
      setError(undefined);
      const data: S3FileMetadata = await uploadFile(file, directory, token);
      // Return an object with both previewUrl and fileKey
      return { previewUrl: data.url.toString(), fileKey: data.key };
    } catch (err: any) {
      setError(err.message || 'File upload failed');
      return undefined;
    } finally {
      setLoading(false);
    }
  }

  return {
    upload,
    loading,
    error,
  };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/drafts/useDraftManager.ts -----
"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import { usePathname } from "next/navigation";
import debounce from "lodash.debounce";

export interface DraftData {
  title: string;
  content: string;
  tags: string[];
  coverImageUrl: string;
  coverImageKey: string;
}

const DRAFT_VERSION = 2;

export function useDraftManager({
  userId,
  contentType,
}: {
  userId?: string | null;
  contentType: string;
}) {
  const pathname = usePathname();
  const effectiveUserId = userId ?? "guest";

  const DRAFT_STORAGE_KEY = `zblog_${contentType}_draft_v${DRAFT_VERSION}_${effectiveUserId}`;
  const DISCARD_FLAG_KEY = `zblog_${contentType}_discarded_v${DRAFT_VERSION}_${effectiveUserId}`;

  const [draft, setDraft] = useState<DraftData>({
    title: "",
    content: "",
    tags: [],
    coverImageUrl: "",
    coverImageKey: "",
  });
  const [hasChanges, setHasChanges] = useState(false);
  const [showResumeModal, setShowResumeModal] = useState(false);
  const [autoSaveStatus, setAutoSaveStatus] = useState("No changes");

  // Refs to control prompting and re‑loading
  const hasPromptedRef = useRef(false);
  const shouldReloadDraftRef = useRef(true);

  // Utility: Check if a draft is empty.
  const isDraftEmpty = useCallback((d: DraftData) => {
    return (
      !d.title &&
      !d.content &&
      !d.coverImageUrl &&
      !d.coverImageKey &&
      (!d.tags || d.tags.length === 0)
    );
  }, []);

  // Utility: Load a draft from localStorage.
  const loadLocalDraft = useCallback((): DraftData | null => {
    const raw = localStorage.getItem(DRAFT_STORAGE_KEY);
    if (!raw) return null;
    try {
      return JSON.parse(raw) as DraftData;
    } catch {
      localStorage.removeItem(DRAFT_STORAGE_KEY);
      return null;
    }
  }, [DRAFT_STORAGE_KEY]);

  // Utility: Clear draft from state and storage.
  const clearAllDraftData = useCallback(() => {
    localStorage.removeItem(DRAFT_STORAGE_KEY);
    localStorage.removeItem(DISCARD_FLAG_KEY);
    setDraft({
      title: "",
      content: "",
      tags: [],
      coverImageUrl: "",
      coverImageKey: "",
    });
    setHasChanges(false);
    setAutoSaveStatus("No changes");
  }, [DRAFT_STORAGE_KEY, DISCARD_FLAG_KEY]);

  // --- Draft Loading Effect ---
  useEffect(() => {
    if (!shouldReloadDraftRef.current) return;

    const discardFlag = localStorage.getItem(DISCARD_FLAG_KEY);
    if (discardFlag === "true") {
      clearAllDraftData();
      shouldReloadDraftRef.current = false;
      return;
    }

    const existingDraft = loadLocalDraft();
    if (existingDraft) {
      setDraft(existingDraft);
      if (pathname === "/express" && !hasPromptedRef.current) {
        setShowResumeModal(true);
        hasPromptedRef.current = true;
      }
    }
    shouldReloadDraftRef.current = false;
  }, [pathname, loadLocalDraft, clearAllDraftData]);

  // When leaving the create page, reset our flags so that on return the draft reloads.
  useEffect(() => {
    if (pathname !== "/express") {
      hasPromptedRef.current = false;
      shouldReloadDraftRef.current = true;
    }
  }, [pathname]);

  // --- Resume / Discard Handlers ---
  const handleResumeDraft = useCallback(() => {
    setShowResumeModal(false);
    // Mark unsaved changes so that auto-save continues.
    setHasChanges(true);
  }, []);

  const handleDiscardLocalDraft = useCallback(() => {
    localStorage.setItem(DISCARD_FLAG_KEY, "true");
    clearAllDraftData();
    setShowResumeModal(false);
  }, [clearAllDraftData]);

  // --- Auto-save ---
  // Save draft to storage regardless of whether it's "empty"
  const saveDraftToStorage = useCallback((nextDraft: DraftData) => {
    localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(nextDraft));
    setAutoSaveStatus("Saved just now");
  }, [DRAFT_STORAGE_KEY]);

  const debouncedSave = useRef(
    debounce((nextDraft: DraftData) => {
      setAutoSaveStatus("Saving...");
      saveDraftToStorage(nextDraft);
    }, 800)
  ).current;

  useEffect(() => {
    if (!hasChanges) return;
    debouncedSave(draft);
    return () => debouncedSave.cancel();
  }, [draft, hasChanges, debouncedSave]);

  // --- Navigation Warning ---
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (hasChanges && !isDraftEmpty(draft)) {
        e.preventDefault();
        e.returnValue = "";
      }
    };
    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => window.removeEventListener("beforeunload", handleBeforeUnload);
  }, [hasChanges, draft, isDraftEmpty]);

  useEffect(() => {
    const handlePopState = () => {
      if (hasChanges && !isDraftEmpty(draft)) {
        const shouldLeave = window.confirm(
          "You have unsaved changes. Are you sure you want to leave?"
        );
        if (!shouldLeave) {
          window.history.pushState(null, "", window.location.href);
          return false;
        }
      }
      return true;
    };
    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, [hasChanges, draft, isDraftEmpty]);

  // --- Public Methods ---
  const setDraftField = useCallback(
    <K extends keyof DraftData>(field: K, value: DraftData[K]) => {
      setDraft((prev) => ({ ...prev, [field]: value }));
      setHasChanges(true);
    },
    []
  );

  const handleDiscardFromEditor = useCallback(() => {
    if (isDraftEmpty(draft) && !hasChanges) return;
    if (!window.confirm("Discard all changes? This cannot be undone.")) return;
    localStorage.setItem(DISCARD_FLAG_KEY, "true");
    clearAllDraftData();
  }, [draft, hasChanges, isDraftEmpty, clearAllDraftData]);

  const clearDraft = useCallback(() => {
    clearAllDraftData();
  }, [clearAllDraftData]);

  return {
    draft,
    setDraftField,
    hasChanges,
    autoSaveStatus,
    showResumeModal,
    handleResumeDraft,
    handleDiscardLocalDraft,
    handleDiscardFromEditor,
    clearDraft,
  };
}


----- /home/zakaria/zBlog/zblog-frontend/src/app/posts/page.tsx -----
"use client";

import React from "react";
import ExplorePostsContent from "@/components/posts/ExplorePostsContent";

export default function ExplorePostsPage() {
  return (
    <main className="bg-slate-900 text-white min-h-screen pt-4 pb-16 overflow-hidden">
      <ExplorePostsContent />
    </main>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/app/posts/mockPosts.ts -----
import type { PostCardProps } from "@/components/posts/PostCard";

export const mockPosts: PostCardProps[] = [
  {
    id: "1",
    title: "Mastering TypeScript",
    description: "Discover the power of static typing in JavaScript and how it can improve your productivity.",
    author: "Zakaria",
    timestamp: "2 hours ago",
    tags: ["Coding", "TypeScript"],
    imageUrl: "https://picsum.photos/600/400?random=1",
    reactionCount: 24,
    commentCount: 5,
  },
  {
    id: "2",
    title: "Exploring Microservices Architecture",
    description: "Learn how a microservices architecture can help you build scalable applications.",
    author: "Alice",
    timestamp: "3 hours ago",
    tags: ["Microservices", "Architecture"],
    imageUrl: "https://picsum.photos/600/400?random=2",
    reactionCount: 35,
    commentCount: 12,
  },
  {
    id: "3",
    title: "UI/UX Best Practices",
    description: "Designing interfaces that are not only visually appealing but also provide great user experience.",
    author: "Bob",
    timestamp: "5 hours ago",
    tags: ["Design", "UI/UX"],
    imageUrl: "https://picsum.photos/600/400?random=3",
    reactionCount: 10,
    commentCount: 8,
  },
  {
    id: "4",
    title: "Understanding Cloud-Native Development",
    description: "An in-depth look into building applications using cloud-native technologies and microservices.",
    author: "Clara",
    timestamp: "1 day ago",
    tags: ["Cloud", "Microservices"],
    imageUrl: "https://picsum.photos/600/400?random=4",
    reactionCount: 18,
    commentCount: 3,
  },
  {
    id: "5",
    title: "The Future of AI in Software Development",
    description: "How artificial intelligence is reshaping coding, testing, and deployment workflows.",
    author: "Derek",
    timestamp: "2 days ago",
    tags: ["AI", "Software Development"],
    imageUrl: "https://picsum.photos/600/400?random=5",
    reactionCount: 44,
    commentCount: 16,
  },
  {
    id: "6",
    title: "Boosting Productivity with VS Code",
    description: "Tips, tricks, and essential extensions to make Visual Studio Code your power tool.",
    author: "Eva",
    timestamp: "3 days ago",
    tags: ["Productivity", "VS Code"],
    imageUrl: "https://picsum.photos/600/400?random=6",
    reactionCount: 27,
    commentCount: 6,
  },
  {
    id: "7",
    title: "Learning Python: A Beginner's Guide",
    description: "Get started with Python programming with practical examples and exercises.",
    author: "Frank",
    timestamp: "4 days ago",
    tags: ["Coding", "Python"],
    imageUrl: "https://picsum.photos/600/400?random=7",
    reactionCount: 30,
    commentCount: 10,
  },
  {
    id: "8",
    title: "Exploring the World of Data Science",
    description: "Data science and analytics explained with real-world projects and examples.",
    author: "Grace",
    timestamp: "5 days ago",
    tags: ["Data Science", "Analytics"],
    imageUrl: "https://picsum.photos/600/400?random=8",
    reactionCount: 22,
    commentCount: 7,
  },
];


----- /home/zakaria/zBlog/zblog-frontend/src/app/posts/[id]/page.tsx -----
"use client";

import React, { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { useAuth } from "react-oidc-context";
import DOMPurify from "dompurify";
import { getPost, PostDTO } from "@/services/postService";
import PostDetail from "@/components/posts/PostDetail/PostDetail";
import Fallback from "@/components/Fallback/Fallback";
import ErrorBoundary from "@/components/Fallback/ErrorBoundary";

export default function SinglePostPage() {
  const params = useParams();
  const auth = useAuth();
  const postId =
    typeof params?.id === "string"
      ? params.id
      : Array.isArray(params?.id)
      ? params.id[0]
      : "";

  const [post, setPost] = useState<PostDTO | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!auth.isLoading && auth.user) {
      const token = auth.user.access_token;
      getPost(postId, token)
        .then((data) => {
          setPost(data);
          setLoading(false);
        })
        .catch((err) => {
          setError(err.message || "Error loading post");
          setLoading(false);
        });
    }
  }, [postId, auth]);

  if (auth.isLoading || loading) {
    return <Fallback message="Loading post..." />;
  }

  if (error) {
    return <Fallback message={`Error: ${error}`} />;
  }

  if (!post) {
    return <Fallback message="No post found." />;
  }

  // Sanitize HTML content
  const safeContent = DOMPurify.sanitize(post.content);

  return (
    <ErrorBoundary fallback={<Fallback message="Something went wrong while rendering the post." />}>
      <PostDetail
        post={{
          title: post.title,
          coverImageUrl: post.bannerImageUrl || "/default-cover.jpg",
          content: safeContent,
          tags: post.tags || [],
          publishedAt: post.createdAt ? new Date(post.createdAt) : new Date(),
          author: {
            name: post.authorId ? `User ${post.authorId.substring(0, 6)}` : "Unknown Author",
            avatarUrl: "/avatars/default.png",
          },
        }}
      />
    </ErrorBoundary>
  );
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/config/S3SecurityConfig.java -----
package com.zblog.s3core.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@EnableWebSecurity
public class S3SecurityConfig {

    @Value("${aws.cognito.issuer-uri}")
    private String issuerUri;

    /**
     * Allow all origins/methods/headers (temporary dev setup).
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();

        config.setAllowedOrigins(List.of("*"));
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(false); // cannot be true when using wildcard origin

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }

    /**
     * Secures /internal/files/** with JWT.
     */
    @Bean
    @Order(1)
    public SecurityFilterChain internalFilesSecurityChain(HttpSecurity http) throws Exception {
        http
                .securityMatcher("/internal/files/**")
                .cors(Customizer.withDefaults())
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));
        return http.build();
    }

    /**
     * Default open policy for all public endpoints (including /s3/files).
     */
    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityChain(HttpSecurity http) throws Exception {
        http
                .cors(Customizer.withDefaults())
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/s3/health").permitAll()
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                        .anyRequest().permitAll()
                )
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));
        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withJwkSetUri(issuerUri + "/.well-known/jwks.json").build();
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/config/S3Config.java -----
package com.zblog.s3core.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.presigner.S3Presigner;

@Configuration
public class S3Config {

    private final S3Properties s3Properties;

    public S3Config(S3Properties s3Properties) {
        this.s3Properties = s3Properties;
    }

    @Bean
    public S3Client s3Client() {
        return S3Client.builder()
                .region(Region.of(s3Properties.getRegion()))
                .build();
    }

    @Bean
    public S3Presigner s3Presigner() {
        return S3Presigner.builder()
                .region(Region.of(s3Properties.getRegion()))
                .build();
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/config/S3Properties.java -----
package com.zblog.s3core.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
@ConfigurationProperties(prefix = "aws.s3")
public class S3Properties {

    private String bucketName;
    private String region;
    private long uploadExpirySeconds;
    private long maxFileSize;
    private List<String> allowedMimeTypes;
    private List<String> disallowedMimeTypes;

    public String getBucketName() {
        return bucketName;
    }
    public void setBucketName(String bucketName) {
        this.bucketName = bucketName;
    }

    public String getRegion() {
        return region;
    }
    public void setRegion(String region) {
        this.region = region;
    }

    public long getUploadExpirySeconds() {
        return uploadExpirySeconds;
    }
    public void setUploadExpirySeconds(long uploadExpirySeconds) {
        this.uploadExpirySeconds = uploadExpirySeconds;
    }

    public long getMaxFileSize() {
        return maxFileSize;
    }
    public void setMaxFileSize(long maxFileSize) {
        this.maxFileSize = maxFileSize;
    }

    public List<String> getAllowedMimeTypes() {
        return allowedMimeTypes;
    }
    public void setAllowedMimeTypes(List<String> allowedMimeTypes) {
        this.allowedMimeTypes = allowedMimeTypes;
    }

    public List<String> getDisallowedMimeTypes() {
        return disallowedMimeTypes;
    }
    public void setDisallowedMimeTypes(List<String> disallowedMimeTypes) {
        this.disallowedMimeTypes = disallowedMimeTypes;
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/controller/HealthCheckController.java -----
package com.zblog.s3core.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/s3/health")
public class HealthCheckController {

    @GetMapping
    public String health() {
        return "OK";
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/controller/FileController.java -----
package com.zblog.s3core.controller;

import com.zblog.s3core.dto.S3FileMetadata;
import com.zblog.s3core.exception.S3ServiceException;
import com.zblog.s3core.service.S3Service;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.net.URL;
import java.util.List;

@RestController
@RequestMapping("/s3/files")
public class FileController {

    private final S3Service s3Service;

    public FileController(S3Service s3Service) {
        this.s3Service = s3Service;
    }

    /**
     * Upload a file to S3. Returns the file metadata (key, url, etc.).
     */
    @PostMapping
    public ResponseEntity<S3FileMetadata> uploadFile(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "directory", defaultValue = "posts") String directory) throws S3ServiceException {

        S3FileMetadata metadata = s3Service.uploadFile(file, directory);
        return ResponseEntity.ok(metadata);
    }

    /**
     * Get a presigned download URL or a direct public URL if isPublic=true.
     */
    @GetMapping(value = "/**", params = "!prefix")
    public ResponseEntity<String> getFileUrl(
            HttpServletRequest request,
            @RequestParam(value = "public", defaultValue = "false") boolean isPublic) throws S3ServiceException {

        String fullPath = request.getRequestURI().substring(
                request.getRequestURI().indexOf("/internal/files/") + "/internal/files/".length()
        );

        URL url = s3Service.getFileUrl(fullPath, isPublic);
        return ResponseEntity.ok(url.toString());
    }

    /**
     * Generate a presigned upload URL for direct client PUT.
     */
    @GetMapping("/{fileKey}/presign-upload")
    public ResponseEntity<String> getPresignedUploadUrl(
            @PathVariable("fileKey") String fileKey) throws S3ServiceException {

        URL url = s3Service.generatePresignedUploadUrl(fileKey);
        return ResponseEntity.ok(url.toString());
    }

    /**
     * Delete an existing file from S3.
     */
    @DeleteMapping("/**")
    public ResponseEntity<String> deleteFile(HttpServletRequest request) throws S3ServiceException {
        // Extract full path after "/internal/files/"
        String fullPath = request.getRequestURI().substring(
                request.getRequestURI().indexOf("/internal/files/") + "/internal/files/".length()
        );

        s3Service.deleteFile(fullPath);
        return ResponseEntity.ok("File deleted successfully");
    }

    /**
     * List files by prefix (e.g., "posts/").
     * GET /internal/files?prefix=avatars/
     */
    @GetMapping
    public ResponseEntity<List<S3FileMetadata>> listFiles(@RequestParam("prefix") String prefix) throws S3ServiceException {
        List<S3FileMetadata> files = s3Service.listFiles(prefix);
        return ResponseEntity.ok(files);
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/dto/S3FileMetadata.java -----
package com.zblog.s3core.dto;

import java.net.URL;
import java.time.Instant;

public class S3FileMetadata {
    private String key;
    private long size;
    private String mimeType;
    private Instant uploadTimestamp;
    private URL url;

    public String getKey() {
        return key;
    }
    public void setKey(String key) {
        this.key = key;
    }

    public long getSize() {
        return size;
    }
    public void setSize(long size) {
        this.size = size;
    }

    public String getMimeType() {
        return mimeType;
    }
    public void setMimeType(String mimeType) {
        this.mimeType = mimeType;
    }

    public Instant getUploadTimestamp() {
        return uploadTimestamp;
    }
    public void setUploadTimestamp(Instant uploadTimestamp) {
        this.uploadTimestamp = uploadTimestamp;
    }

    public URL getUrl() {
        return url;
    }
    public void setUrl(URL url) {
        this.url = url;
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/S3CoreApplication.java -----
package com.zblog.s3core;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class S3CoreApplication {

    public static void main(String[] args) {
        SpringApplication.run(S3CoreApplication.class, args);
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/service/impl/S3ServiceImpl.java -----
package com.zblog.s3core.service.impl;

import com.zblog.s3core.config.S3Properties;
import com.zblog.s3core.dto.S3FileMetadata;
import com.zblog.s3core.exception.S3ServiceException;
import com.zblog.s3core.service.S3Service;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;
import software.amazon.awssdk.core.sync.RequestBody;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.*;
import software.amazon.awssdk.services.s3.presigner.S3Presigner;
import software.amazon.awssdk.services.s3.presigner.model.GetObjectPresignRequest;
import software.amazon.awssdk.services.s3.presigner.model.PutObjectPresignRequest;

import java.io.IOException;
import java.net.URL;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Service
public class S3ServiceImpl implements S3Service {

    private final S3Client s3Client;
    private final S3Presigner s3Presigner;
    private final S3Properties s3Properties;

    public S3ServiceImpl(S3Client s3Client, S3Presigner s3Presigner, S3Properties s3Properties) {
        this.s3Client = s3Client;
        this.s3Presigner = s3Presigner;
        this.s3Properties = s3Properties;
    }

    @Override
    public S3FileMetadata uploadFile(MultipartFile file, String directoryPrefix) throws S3ServiceException {
        if (file.isEmpty()) {
            throw new S3ServiceException("File is empty");
        }
        if (file.getSize() > s3Properties.getMaxFileSize()) {
            throw new S3ServiceException("File exceeds maximum allowed size");
        }

        // MIME type checks
        String mimeType = file.getContentType();
        if (s3Properties.getAllowedMimeTypes() != null && !s3Properties.getAllowedMimeTypes().isEmpty() &&
                !s3Properties.getAllowedMimeTypes().contains(mimeType)) {
            throw new S3ServiceException("MIME type not allowed: " + mimeType);
        }
        if (s3Properties.getDisallowedMimeTypes() != null &&
                s3Properties.getDisallowedMimeTypes().contains(mimeType)) {
            throw new S3ServiceException("MIME type is disallowed: " + mimeType);
        }

        // Generate a unique key
        String originalFilename = StringUtils.cleanPath(file.getOriginalFilename());
        String uniqueKey = generateUniqueKey(directoryPrefix, originalFilename);

        PutObjectRequest putObjectRequest = PutObjectRequest.builder()
                .bucket(s3Properties.getBucketName())
                .key(uniqueKey)
                .contentType(mimeType)
                .build();

        try {
            s3Client.putObject(
                    putObjectRequest,
                    RequestBody.fromInputStream(file.getInputStream(), file.getSize())
            );
        } catch (IOException e) {
            throw new S3ServiceException("Failed to read file input stream", e);
        } catch (S3Exception e) {
            throw new S3ServiceException("Error uploading file to S3: " + e.awsErrorDetails().errorMessage(), e);
        }

        // Retrieve a presigned or direct URL
        URL fileUrl = getFileUrl(uniqueKey, false);

        // Build response
        S3FileMetadata metadata = new S3FileMetadata();
        metadata.setKey(uniqueKey);
        metadata.setSize(file.getSize());
        metadata.setMimeType(mimeType);
        metadata.setUploadTimestamp(Instant.now());
        metadata.setUrl(fileUrl);

        return metadata;
    }

    @Override
    public URL getFileUrl(String key, boolean isPublic) throws S3ServiceException {
        if (isPublic) {
            // Direct S3 URL
            String urlString = String.format(
                    "https://%s.s3.%s.amazonaws.com/%s",
                    s3Properties.getBucketName(),
                    s3Properties.getRegion(),
                    key
            );
            return buildUrl(urlString);
        } else {
            // Generate a presigned URL with a time-limited expiry
            GetObjectRequest getObjectRequest = GetObjectRequest.builder()
                    .bucket(s3Properties.getBucketName())
                    .key(key)
                    .build();

            GetObjectPresignRequest presignRequest = GetObjectPresignRequest.builder()
                    .signatureDuration(Duration.ofSeconds(s3Properties.getUploadExpirySeconds()))
                    .getObjectRequest(getObjectRequest)
                    .build();

            return s3Presigner.presignGetObject(presignRequest).url();
        }
    }

    @Override
    public URL generatePresignedUploadUrl(String key) throws S3ServiceException {
        try {
            PutObjectRequest putObjectRequest = PutObjectRequest.builder()
                    .bucket(s3Properties.getBucketName())
                    .key(key)
                    .build();

            PutObjectPresignRequest presignRequest = PutObjectPresignRequest.builder()
                    .signatureDuration(Duration.ofSeconds(s3Properties.getUploadExpirySeconds()))
                    .putObjectRequest(putObjectRequest)
                    .build();

            return s3Presigner.presignPutObject(presignRequest).url();
        } catch (S3Exception e) {
            throw new S3ServiceException("Error generating presigned upload URL: " + e.awsErrorDetails().errorMessage(), e);
        }
    }

    @Override
    public void deleteFile(String key) throws S3ServiceException {
        try {
            DeleteObjectRequest deleteObjectRequest = DeleteObjectRequest.builder()
                    .bucket(s3Properties.getBucketName())
                    .key(key)
                    .build();
            s3Client.deleteObject(deleteObjectRequest);
        } catch (S3Exception e) {
            throw new S3ServiceException("Error deleting file from S3: " + e.awsErrorDetails().errorMessage(), e);
        }
    }

    @Override
    public List<S3FileMetadata> listFiles(String prefix) throws S3ServiceException {
        List<S3FileMetadata> files = new ArrayList<>();

        try {
            ListObjectsV2Request listReq = ListObjectsV2Request.builder()
                    .bucket(s3Properties.getBucketName())
                    .prefix(prefix)
                    .build();

            ListObjectsV2Response listRes = s3Client.listObjectsV2(listReq);

            for (S3Object s3Object : listRes.contents()) {
                // Retrieve additional metadata (HEAD) if needed
                HeadObjectRequest headReq = HeadObjectRequest.builder()
                        .bucket(s3Properties.getBucketName())
                        .key(s3Object.key())
                        .build();
                HeadObjectResponse headRes = s3Client.headObject(headReq);

                S3FileMetadata metadata = new S3FileMetadata();
                metadata.setKey(s3Object.key());
                metadata.setSize(s3Object.size());
                metadata.setMimeType(headRes.contentType());
                metadata.setUploadTimestamp(s3Object.lastModified());
                metadata.setUrl(getFileUrl(s3Object.key(), false));

                files.add(metadata);
            }
        } catch (S3Exception e) {
            throw new S3ServiceException("Error listing files: " + e.awsErrorDetails().errorMessage(), e);
        }

        return files;
    }

    /**
     * Generate a unique S3 object key in the specified directory.
     */
    private String generateUniqueKey(String directoryPrefix, String originalFilename) {
        String sanitizedFilename = originalFilename.replaceAll("[^a-zA-Z0-9.\\-]", "_");
        String uniqueId = UUID.randomUUID().toString();
        if (!directoryPrefix.endsWith("/")) {
            directoryPrefix += "/";
        }
        return directoryPrefix + uniqueId + "_" + sanitizedFilename;
    }

    private URL buildUrl(String urlString) throws S3ServiceException {
        try {
            return new URL(urlString);
        } catch (Exception e) {
            throw new S3ServiceException("Malformed URL: " + urlString, e);
        }
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/service/S3Service.java -----
package com.zblog.s3core.service;

import com.zblog.s3core.dto.S3FileMetadata;
import com.zblog.s3core.exception.S3ServiceException;
import org.springframework.web.multipart.MultipartFile;

import java.net.URL;
import java.util.List;

public interface S3Service {
    S3FileMetadata uploadFile(MultipartFile file, String directoryPrefix) throws S3ServiceException;
    URL getFileUrl(String key, boolean isPublic) throws S3ServiceException;
    URL generatePresignedUploadUrl(String key) throws S3ServiceException;
    void deleteFile(String key) throws S3ServiceException;
    List<S3FileMetadata> listFiles(String prefix) throws S3ServiceException;
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/exception/S3ServiceException.java -----
package com.zblog.s3core.exception;

public class S3ServiceException extends Exception {
    public S3ServiceException(String message) {
        super(message);
    }

    public S3ServiceException(String message, Throwable cause) {
        super(message, cause);
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/exception/GlobalExceptionHandler.java -----
package com.zblog.s3core.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.Instant;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(S3ServiceException.class)
    public ResponseEntity<ErrorResponse> handleS3ServiceException(S3ServiceException ex) {
        ErrorResponse response = new ErrorResponse(
                "S3_ERROR",
                ex.getMessage(),
                Instant.now()
        );
        // You could differentiate 4xx vs. 5xx if needed
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse response = new ErrorResponse(
                "GENERIC_ERROR",
                ex.getMessage(),
                Instant.now()
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}


----- /home/zakaria/zBlog/zblog-backend/s3-core/src/main/java/com/zblog/s3core/exception/ErrorResponse.java -----
package com.zblog.s3core.exception;

import java.time.Instant;

public class ErrorResponse {
    private String code;
    private String message;
    private Instant timestamp;

    public ErrorResponse() {}

    public ErrorResponse(String code, String message, Instant timestamp) {
        this.code = code;
        this.message = message;
        this.timestamp = timestamp;
    }

    public String getCode() {
        return code;
    }
    public void setCode(String code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }

    public Instant getTimestamp() {
        return timestamp;
    }
    public void setTimestamp(Instant timestamp) {
        this.timestamp = timestamp;
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/config/SchedulerConfig.java -----
package com.zblog.zblogpostcore.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;

@Configuration
@EnableScheduling
public class SchedulerConfig {
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/config/GraphQLConfig.java -----
package com.zblog.zblogpostcore.config;

import graphql.language.IntValue;
import graphql.schema.*;
import graphql.schema.idl.RuntimeWiring;
import org.springframework.context.annotation.Configuration;
import org.springframework.graphql.execution.RuntimeWiringConfigurer;

@Configuration
public class GraphQLConfig implements RuntimeWiringConfigurer {

    @Override
    public void configure(RuntimeWiring.Builder builder) {
        GraphQLScalarType longScalar = GraphQLScalarType.newScalar()
                .name("Long")
                .description("A custom scalar for 64-bit integers")
                .coercing(new Coercing<Long, Long>() {
                    @Override
                    public Long serialize(Object dataFetcherResult) throws CoercingSerializeException {
                        if (dataFetcherResult instanceof Long) {
                            return (Long) dataFetcherResult;
                        }
                        throw new CoercingSerializeException("Unable to serialize non-Long");
                    }

                    @Override
                    public Long parseValue(Object input) throws CoercingParseValueException {
                        if (input instanceof Number) {
                            return ((Number) input).longValue();
                        }
                        throw new CoercingParseValueException("Value is not a valid Long");
                    }

                    @Override
                    public Long parseLiteral(Object input) throws CoercingParseLiteralException {
                        if (input instanceof IntValue) {
                            return ((IntValue) input).getValue().longValue();
                        }
                        throw new CoercingParseLiteralException("Value is not a valid Long literal");
                    }
                })
                .build();

        builder.scalar(longScalar);
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/config/WebConfig.java -----
package com.zblog.zblogpostcore.config;

import com.zblog.zblogpostcore.ratelimit.RateLimitInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    private final RateLimitInterceptor rateLimitInterceptor;

    @Autowired
    public WebConfig(RateLimitInterceptor rateLimitInterceptor) {
        this.rateLimitInterceptor = rateLimitInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitInterceptor);
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/config/WebSecurityConfig.java -----
package com.zblog.zblogpostcore.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

    @Value("${aws.cognito.issuer-uri}")
    private String issuerUri;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .cors(Customizer.withDefaults())
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/post/health").permitAll()
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll() // ✅ Allow preflight
                        .requestMatchers("/post/api/public/**").permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();

        config.setAllowedOrigins(List.of("*")); // Use your frontend domain in prod!
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(false); // Cannot be true with wildcard origin

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }

    @Bean
    @Primary
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withJwkSetUri(issuerUri + "/.well-known/jwks.json").build();
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/repository/TagRepository.java -----
package com.zblog.zblogpostcore.repository;

import com.zblog.zblogpostcore.domain.entity.Tag;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface TagRepository extends JpaRepository<Tag, UUID> {
    Optional<Tag> findByNameIgnoreCase(String name);
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/repository/PostRepository.java -----
package com.zblog.zblogpostcore.repository;

import com.zblog.zblogpostcore.domain.entity.Post;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

public interface PostRepository extends JpaRepository<Post, UUID>, JpaSpecificationExecutor<Post> {

    Page<Post> findByAuthorId(String authorId, Pageable pageable);

    Page<Post> findByTitleContainingIgnoreCase(String keyword, Pageable pageable);

    Page<Post> findByTitleContainingIgnoreCaseOrContentContainingIgnoreCase(
            String titleKeyword, String contentKeyword, Pageable pageable);

    Page<Post> findByPublishedTrue(Pageable pageable);
    Page<Post> findByPublishedTrueAndAuthorId(String authorId, Pageable pageable);

    @Query("SELECT p FROM Post p WHERE p.published = false AND p.scheduledPublishAt <= :now")
    List<Post> findReadyToPublish(Instant now);

    Page<Post> findAll(Specification<Post> spec, Pageable pageable);
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/scheduler/PostScheduler.java -----
package com.zblog.zblogpostcore.scheduler;

import com.zblog.zblogpostcore.domain.entity.Post;
import com.zblog.zblogpostcore.repository.PostRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

@Component
public class PostScheduler {

    private final PostRepository postRepository;

    @Autowired
    public PostScheduler(PostRepository postRepository) {
        this.postRepository = postRepository;
    }

    /**
     * Runs every minute (60000 ms)
     * to publish posts whose scheduledPublishAt <= now
     * and isPublished == false.
     */
    @Scheduled(fixedRate = 60000)
    public void publishScheduledPosts() {
        Instant now = Instant.now();
        List<Post> unpublished = postRepository.findReadyToPublish(now);

        if (!unpublished.isEmpty()) {
            for (Post post : unpublished) {
                post.setPublished(true);
            }
            postRepository.saveAll(unpublished);
        }
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/controller/HealthCheckController.java -----
package com.zblog.zblogpostcore.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/post/health")
public class HealthCheckController {

    @GetMapping
    public String health() {
        return "OK";
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/controller/TagController.java -----
package com.zblog.zblogpostcore.controller;

import com.zblog.zblogpostcore.service.TagService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/post/api/tags")
public class TagController {

    private final TagService tagService;

    @Autowired
    public TagController(TagService tagService) {
        this.tagService = tagService;
    }

    // GET /api/tags -> returns a list of tag names
    @GetMapping
    public List<String> getAllTags() {
        return tagService.listAllTags().stream()
                .map(tag -> tag.getName())
                .collect(Collectors.toList());
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/controller/PostController.java -----
package com.zblog.zblogpostcore.controller;

import com.zblog.zblogpostcore.dto.PostDTO;
import com.zblog.zblogpostcore.dto.PostDetailDTO;
import com.zblog.zblogpostcore.service.PostService;
import com.zblog.zblogpostcore.util.SecurityUtil;
import jakarta.validation.constraints.Pattern;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/post/api/posts")
@Validated
public class PostController {

    private final PostService postService;

    @Autowired
    public PostController(PostService postService) {
        this.postService = postService;
    }

    /**
     * Explore posts with optional filtering by keywords and tags, sorting, and pagination.
     *
     * Query parameters:
     * - tags: comma-separated list (optional)
     * - keywords: full-text search (optional)
     * - sort: "recent", "popular", or "mostLiked" (defaults to "recent")
     * - page & size: pagination controls
     */
    @GetMapping("/explore")
    public Page<PostDTO> explorePosts(
            @RequestParam(required = false) String tags,
            @RequestParam(required = false) String keywords,
            @RequestParam(defaultValue = "recent")
            @Pattern(regexp = "recent|popular|mostLiked", message = "Invalid sort value")
            String sort,
            Pageable pageable) {

        String currentUserId = SecurityUtil.getCurrentUserIdOrNull();
        List<String> tagList = (tags != null && !tags.isBlank())
                ? List.of(tags.split(",")).stream().map(String::trim).filter(s -> !s.isEmpty()).collect(Collectors.toList())
                : null;
        return postService.explorePosts(keywords, tagList, sort, pageable, currentUserId);
    }

    // CREATE
    @PostMapping
    public PostDTO createPost(@RequestBody PostDTO postDTO) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        return postService.createPost(postDTO, currentUserId);
    }

    // READ (single post)
    @GetMapping("/{postId}")
    public PostDetailDTO getPost(@PathVariable("postId") UUID postId) {
        String currentUserId = SecurityUtil.getCurrentUserIdOrNull();
        return postService.getFullPost(postId, currentUserId);
    }

    // UPDATE
    @PutMapping("/{postId}")
    public PostDTO updatePost(@PathVariable("postId") UUID postId, @RequestBody PostDTO postDTO) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        return postService.updatePost(postId, postDTO, currentUserId);
    }

    // DELETE
    @DeleteMapping("/{postId}")
    public void deletePost(@PathVariable("postId") UUID postId) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        postService.deletePost(postId, currentUserId);
    }

    // LIST/PAGINATION - gets all or only published
    @GetMapping
    public Page<PostDTO> getAllPosts(@RequestParam(value = "publishedOnly", defaultValue = "true") boolean publishedOnly,
                                     Pageable pageable) {
        return postService.getAllPosts(publishedOnly, pageable);
    }

    // SEARCH
    @GetMapping("/search")
    public Page<PostDTO> searchPosts(@RequestParam("keyword") String keyword,
                                     @RequestParam(value = "publishedOnly", defaultValue = "true") boolean publishedOnly,
                                     Pageable pageable) {
        return postService.searchPosts(keyword, publishedOnly, pageable);
    }

    // LIST BY AUTHOR
    @GetMapping("/by-author/{authorId}")
    public Page<PostDTO> getPostsByAuthor(@PathVariable("authorId") String authorId,
                                          @RequestParam(value = "publishedOnly", defaultValue = "true") boolean publishedOnly,
                                          Pageable pageable) {
        return postService.getPostsByAuthor(authorId, publishedOnly, pageable);
    }

    // INCREMENT VIEW COUNT
    @PatchMapping("/{postId}/view")
    public PostDTO incrementView(@PathVariable("postId") UUID postId) {
        return postService.incrementViewCount(postId);
    }

    // REACT
    @PatchMapping("/{postId}/react")
    public PostDTO react(@PathVariable("postId") UUID postId,
                         @RequestParam("type") String reactionType) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        return postService.reactToPost(postId, reactionType, currentUserId);
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/dto/PostDTO.java -----
package com.zblog.zblogpostcore.dto;

import jakarta.validation.constraints.NotBlank;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

public class PostDTO {

    private UUID id;
    private String authorId;

    @NotBlank(message="Title cannot be blank")
    private String title;

    @NotBlank(message="Content cannot be blank")
    private String content;

    private boolean published;
    private long viewCount;
    private long likeCount;
    private long heartCount;
    private long bookmarkCount;

    // Renamed from bannerImageFileId to bannerImageKey
    private String bannerImageKey;

    private String bannerImageUrl;   // ephemeral or fallback
    private Instant createdAt;
    private Instant updatedAt;
    private Instant scheduledPublishAt;

    private List<String> tags;

    public UUID getId() {
        return id;
    }
    public void setId(UUID id) {
        this.id = id;
    }

    public String getAuthorId() {
        return authorId;
    }
    public void setAuthorId(String authorId) {
        this.authorId = authorId;
    }

    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }
    public void setContent(String content) {
        this.content = content;
    }

    public boolean isPublished() {
        return published;
    }
    public void setPublished(boolean published) {
        this.published = published;
    }

    public long getViewCount() {
        return viewCount;
    }
    public void setViewCount(long viewCount) {
        this.viewCount = viewCount;
    }

    public long getLikeCount() {
        return likeCount;
    }
    public void setLikeCount(long likeCount) {
        this.likeCount = likeCount;
    }

    public long getHeartCount() {
        return heartCount;
    }
    public void setHeartCount(long heartCount) {
        this.heartCount = heartCount;
    }

    public long getBookmarkCount() {
        return bookmarkCount;
    }
    public void setBookmarkCount(long bookmarkCount) {
        this.bookmarkCount = bookmarkCount;
    }

    public String getBannerImageKey() {
        return bannerImageKey;
    }
    public void setBannerImageKey(String bannerImageKey) {
        this.bannerImageKey = bannerImageKey;
    }

    public String getBannerImageUrl() {
        return bannerImageUrl;
    }
    public void setBannerImageUrl(String bannerImageUrl) {
        this.bannerImageUrl = bannerImageUrl;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }
    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }
    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Instant getScheduledPublishAt() {
        return scheduledPublishAt;
    }
    public void setScheduledPublishAt(Instant scheduledPublishAt) {
        this.scheduledPublishAt = scheduledPublishAt;
    }

    public List<String> getTags() {
        return tags;
    }
    public void setTags(List<String> tags) {
        this.tags = tags;
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/dto/PostDetailDTO.java -----
package com.zblog.zblogpostcore.dto;

import jakarta.validation.constraints.NotBlank;
import java.time.Instant;
import java.util.List;
import java.util.UUID;

public class PostDetailDTO {

    private UUID id;
    private String authorId;

    @NotBlank(message="Title cannot be blank")
    private String title;

    @NotBlank(message="Content cannot be blank")
    private String content; // Full post content

    private boolean published;
    private long viewCount;
    private long likeCount;
    private long heartCount;
    private long bookmarkCount;

    private String bannerImageKey;
    private String bannerImageUrl;   // Resolved URL for banner image

    private Instant createdAt;
    private Instant updatedAt;
    private Instant scheduledPublishAt;

    private List<String> tags;

    public long getViewCount() {
        return viewCount;
    }

    public void setViewCount(long viewCount) {
        this.viewCount = viewCount;
    }

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getAuthorId() {
        return authorId;
    }

    public void setAuthorId(String authorId) {
        this.authorId = authorId;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public boolean isPublished() {
        return published;
    }

    public void setPublished(boolean published) {
        this.published = published;
    }

    public long getLikeCount() {
        return likeCount;
    }

    public void setLikeCount(long likeCount) {
        this.likeCount = likeCount;
    }

    public long getHeartCount() {
        return heartCount;
    }

    public void setHeartCount(long heartCount) {
        this.heartCount = heartCount;
    }

    public long getBookmarkCount() {
        return bookmarkCount;
    }

    public void setBookmarkCount(long bookmarkCount) {
        this.bookmarkCount = bookmarkCount;
    }

    public String getBannerImageKey() {
        return bannerImageKey;
    }

    public void setBannerImageKey(String bannerImageKey) {
        this.bannerImageKey = bannerImageKey;
    }

    public String getBannerImageUrl() {
        return bannerImageUrl;
    }

    public void setBannerImageUrl(String bannerImageUrl) {
        this.bannerImageUrl = bannerImageUrl;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Instant getScheduledPublishAt() {
        return scheduledPublishAt;
    }

    public void setScheduledPublishAt(Instant scheduledPublishAt) {
        this.scheduledPublishAt = scheduledPublishAt;
    }

    public List<String> getTags() {
        return tags;
    }

    public void setTags(List<String> tags) {
        this.tags = tags;
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/ratelimit/RateLimitInterceptor.java -----
package com.zblog.zblogpostcore.ratelimit;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class RateLimitInterceptor implements HandlerInterceptor {

    // userId + endpoint + postId -> last 5 timestamps
    private final Map<String, CircularBuffer> callsMap = new ConcurrentHashMap<>();

    // Limit: 5 calls in 1 minute
    private static final int MAX_CALLS = 5;
    private static final long INTERVAL_MS = 60_000;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {

        // Only handle certain endpoints
        String uri = request.getRequestURI();
        if (isRateLimitedEndpoint(uri) && "PATCH".equalsIgnoreCase(request.getMethod())) {

            String userId = request.getUserPrincipal() != null ? request.getUserPrincipal().getName() : "anonymous";
            String postId = extractPostId(uri); // e.g. from /api/posts/{postId}/react or /view
            if (postId == null) {
                return true; // no rate limit if no postId
            }

            String key = userId + "_" + uri;

            CircularBuffer timestamps = callsMap.computeIfAbsent(key, k -> new CircularBuffer(MAX_CALLS));

            Instant now = Instant.now();
            // Add timestamp, check oldest
            if (!timestamps.allow(now.toEpochMilli(), INTERVAL_MS)) {
                response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
                response.getWriter().write("Rate limit exceeded. Try again later.");
                return false;
            }
        }

        return true;
    }

    private boolean isRateLimitedEndpoint(String uri) {
        return uri.matches(".*/api/posts/.*/react.*") || uri.matches(".*/api/posts/.*/view.*");
    }

    private String extractPostId(String uri) {
        // naive approach: /api/posts/{postId}/react
        String[] parts = uri.split("/");
        if (parts.length >= 4) {
            return parts[3]; // the part after /api/posts/
        }
        return null;
    }

    // Circular buffer storing timestamps in ms
    static class CircularBuffer {
        private final long[] times;
        private int index;

        public CircularBuffer(int size) {
            this.times = new long[size];
            this.index = 0;
        }

        public synchronized boolean allow(long now, long intervalMs) {
            // Check oldest
            long oldest = times[index];
            if (now - oldest < intervalMs) {
                // within interval => not allowed
                return false;
            }
            times[index] = now;
            index = (index + 1) % times.length;
            return true;
        }
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/util/SecurityUtil.java -----
package com.zblog.zblogpostcore.util;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

public class SecurityUtil {

    public static String getCurrentUserId() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || auth.getName() == null) {
            throw new SecurityException("No authenticated user");
        }
        // 'auth.getName()' is typically the 'sub' from the JWT
        return auth.getName();
    }

    public static String getCurrentUserIdOrNull() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null) {
            return null;
        }
        return auth.getName();
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/client/FileClient.java -----
package com.zblog.zblogpostcore.client;

import com.zblog.zblogpostcore.client.dto.FileMetadataDTO;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

/**
 * A REST-based client to communicate with the s3-core microservice.
 * This ensures post-core does NOT rely on s3-core's Java code,
 * but only on a well-defined REST contract.
 */
@Component
public class FileClient {

    private final RestTemplate restTemplate;
    private final String s3CoreUrl;

    public FileClient(@Value("${s3.core.url}") String s3CoreUrl,
                      RestTemplateBuilder restTemplateBuilder) {
        this.s3CoreUrl = s3CoreUrl;
        this.restTemplate = restTemplateBuilder.build();
    }

    /**
     * Retrieve metadata (including a presigned URL) for a given fileId.
     * The s3-core endpoint is assumed:
     *  GET /internal/files/{fileId}?public=false
     * returning JSON with the final presigned or public URL.
     */
    @CircuitBreaker(name = "s3CoreCircuitBreaker", fallbackMethod = "getFileMetadataFallback")
    @Retry(name = "s3CoreRetry")
    public FileMetadataDTO getFileMetadata(String fileId, boolean isPublic) {
        String url = String.format("%s/s3/files/%s?public=%s", s3CoreUrl, fileId, isPublic);
        ResponseEntity<FileMetadataDTO> response = restTemplate.getForEntity(url, FileMetadataDTO.class);
        return response.getBody();
    }

    /**
     * Delete a file from s3-core.
     * The s3-core endpoint is:
     *  DELETE /internal/files/{fileId}
     */
    @CircuitBreaker(name = "s3CoreCircuitBreaker", fallbackMethod = "deleteFileFallback")
    @Retry(name = "s3CoreRetry")
    public void deleteFile(String fileId) {
        String url = String.format("%s/internal/files/%s", s3CoreUrl, fileId);
        restTemplate.exchange(url, HttpMethod.DELETE, null, Void.class);
    }

    // --- Fallbacks if s3-core is unreachable ---

    private FileMetadataDTO getFileMetadataFallback(String fileId, boolean isPublic, Throwable t) {
        // Return an empty or placeholder object
        FileMetadataDTO fallback = new FileMetadataDTO();
        fallback.setKey(fileId);
        fallback.setUrl(null);
        fallback.setMimeType(null);
        fallback.setSize(0);
        return fallback;
    }

    private void deleteFileFallback(String fileId, Throwable t) {
        // Possibly log or do nothing. The file won't get deleted in s3.
        // You could queue a retry or mark "orphan" file references.
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/client/dto/FileMetadataDTO.java -----
package com.zblog.zblogpostcore.client.dto;

import java.time.Instant;

/**
 * Mirrors the file response from s3-core:
 * GET /internal/files/{fileId}
 */
public class FileMetadataDTO {
    private String key;
    private long size;
    private String mimeType;
    private Instant uploadTimestamp;
    private String url; // final presigned or public URL

    public String getKey() { return key; }
    public void setKey(String key) { this.key = key; }

    public long getSize() { return size; }
    public void setSize(long size) { this.size = size; }

    public String getMimeType() { return mimeType; }
    public void setMimeType(String mimeType) { this.mimeType = mimeType; }

    public Instant getUploadTimestamp() { return uploadTimestamp; }
    public void setUploadTimestamp(Instant uploadTimestamp) { this.uploadTimestamp = uploadTimestamp; }

    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/service/TagService.java -----
package com.zblog.zblogpostcore.service;

import com.zblog.zblogpostcore.domain.entity.Tag;
import com.zblog.zblogpostcore.repository.TagRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Service
public class TagService {

    private final TagRepository tagRepository;

    @Autowired
    public TagService(TagRepository tagRepository) {
        this.tagRepository = tagRepository;
    }

    public List<Tag> listAllTags() {
        return tagRepository.findAll();
    }

    public Tag getTagById(UUID id) {
        return tagRepository.findById(id).orElse(null);
    }

    public Tag createOrUpdateTag(String name) {
        return tagRepository.findByNameIgnoreCase(name)
                .orElseGet(() -> {
                    Tag newTag = new Tag();
                    newTag.setName(name);
                    return tagRepository.save(newTag);
                });
    }

    public void deleteTag(UUID id) {
        tagRepository.deleteById(id);
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/service/impl/PostServiceImpl.java -----
package com.zblog.zblogpostcore.service.impl;

import com.zblog.zblogpostcore.client.FileClient;
import com.zblog.zblogpostcore.domain.entity.Post;
import com.zblog.zblogpostcore.domain.entity.Tag;
import com.zblog.zblogpostcore.dto.PostDTO;
import com.zblog.zblogpostcore.dto.PostDetailDTO;
import com.zblog.zblogpostcore.exception.PostNotFoundException;
import com.zblog.zblogpostcore.repository.PostRepository;
import com.zblog.zblogpostcore.repository.TagRepository;
import com.zblog.zblogpostcore.service.PostService;
import org.jsoup.Jsoup;
import org.jsoup.safety.Safelist;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;
import jakarta.persistence.criteria.Predicate;

@Service
public class PostServiceImpl implements PostService {

    private final PostRepository postRepository;
    private final TagRepository tagRepository;
    private final FileClient fileClient;

    @Value("${aws.bucketName}")
    private String bucketName;

    @Value("${aws.region}")
    private String awsRegion;

    public PostServiceImpl(PostRepository postRepository,
                           TagRepository tagRepository,
                           FileClient fileClient) {
        this.postRepository = postRepository;
        this.tagRepository = tagRepository;
        this.fileClient = fileClient;
    }

    @Override
    public PostDTO createPost(PostDTO postDTO, String currentUserId) {
        Post post = new Post();
        post.setAuthorId(currentUserId);
        post.setTitle(postDTO.getTitle());
        post.setContent(postDTO.getContent());
        post.setPublished(postDTO.isPublished());
        post.setBannerImageKey(postDTO.getBannerImageKey()); // store the S3 key
        post.setScheduledPublishAt(postDTO.getScheduledPublishAt());

        // Initialize counters
        post.setLikeCount(0);
        post.setHeartCount(0);
        post.setBookmarkCount(0);

        if (postDTO.getTags() != null) {
            post.setTags(resolveTags(postDTO.getTags()));
        }
        Post saved = postRepository.save(post);
        return mapToDTO(saved, true);
    }

    @Override
    public PostDTO updatePost(UUID postId, PostDTO postDTO, String currentUserId) {
        Post existing = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found"));

        if (!existing.getAuthorId().equals(currentUserId)) {
            throw new SecurityException("Not authorized to edit this post");
        }

        existing.setTitle(postDTO.getTitle());
        existing.setContent(postDTO.getContent());
        existing.setPublished(postDTO.isPublished());
        existing.setBannerImageKey(postDTO.getBannerImageKey());
        existing.setScheduledPublishAt(postDTO.getScheduledPublishAt());

        // Update tags
        existing.getTags().clear();
        if (postDTO.getTags() != null) {
            existing.getTags().addAll(resolveTags(postDTO.getTags()));
        }

        Post saved = postRepository.save(existing);
        return mapToDTO(saved, true);
    }

    @Override
    public void deletePost(UUID postId, String currentUserId) {
        Post existing = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found"));

        if (!existing.getAuthorId().equals(currentUserId)) {
            throw new SecurityException("Not authorized to delete this post");
        }

        // Optionally delete the S3 file
        if (existing.getBannerImageKey() != null) {
            try {
                fileClient.deleteFile(existing.getBannerImageKey());
            } catch (Exception e) {
                // swallow or log
            }
        }
        postRepository.delete(existing);
    }

    @Override
    public PostDTO getPost(UUID postId, String currentUserId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found"));

        // If not published, only the owner can see it
        if (!post.isPublished() && !post.getAuthorId().equals(currentUserId)) {
            throw new SecurityException("This post is unpublished and you are not the owner");
        }
        return mapToDTO(post, true);
    }

    @Override
    public Page<PostDTO> getAllPosts(boolean onlyPublished, Pageable pageable) {
        if (onlyPublished) {
            return postRepository.findByPublishedTrue(pageable)
                    .map(entity -> mapToDTO(entity, false));
        }
        return postRepository.findAll(pageable)
                .map(entity -> mapToDTO(entity, false));
    }

    @Override
    public Page<PostDTO> searchPosts(String keyword, boolean onlyPublished, Pageable pageable) {
        var page = postRepository.findByTitleContainingIgnoreCaseOrContentContainingIgnoreCase(
                keyword, keyword, pageable);

        if (onlyPublished) {
            var filtered = page.getContent().stream()
                    .filter(Post::isPublished)
                    .collect(Collectors.toList());
            return new PageImpl<>(
                    filtered.stream().map(p -> mapToDTO(p, false)).collect(Collectors.toList()),
                    pageable,
                    filtered.size()
            );
        }
        return page.map(post -> mapToDTO(post, false));
    }

    @Override
    public Page<PostDTO> getPostsByAuthor(String authorId, boolean onlyPublished, Pageable pageable) {
        if (onlyPublished) {
            return postRepository.findByPublishedTrueAndAuthorId(authorId, pageable)
                    .map(entity -> mapToDTO(entity, false));
        } else {
            return postRepository.findByAuthorId(authorId, pageable)
                    .map(entity -> mapToDTO(entity, false));
        }
    }

    @Override
    public PostDTO incrementViewCount(UUID postId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found"));
        post.setViewCount(post.getViewCount() + 1);
        Post saved = postRepository.save(post);
        return mapToDTO(saved, false);
    }

    @Override
    public PostDTO reactToPost(UUID postId, String reactionType, String currentUserId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found"));

        switch (reactionType.toLowerCase()) {
            case "like" -> post.setLikeCount(post.getLikeCount() + 1);
            case "heart" -> post.setHeartCount(post.getHeartCount() + 1);
            case "bookmark" -> post.setBookmarkCount(post.getBookmarkCount() + 1);
            default -> throw new IllegalArgumentException("Unknown reaction type: " + reactionType);
        }
        Post saved = postRepository.save(post);
        return mapToDTO(saved, false);
    }

    @Override
    public void validatePostExists(UUID postId) {
        if (!postRepository.existsById(postId)) {
            throw new PostNotFoundException("Post not found for id: " + postId);
        }
    }

    // ----------------- Helpers -----------------

    /**
     * Convert Post entity to PostDTO and resolve banner image URL if needed.
     */
    private PostDTO mapToDTO(Post post, boolean resolveBannerUrl) {
        PostDTO dto = new PostDTO();
        dto.setId(post.getId());
        dto.setAuthorId(post.getAuthorId());
        dto.setTitle(post.getTitle());
        // Generate a sanitized excerpt from HTML content.
        dto.setContent(generateExcerpt(post.getContent(), 150));
        dto.setPublished(post.isPublished());
        dto.setViewCount(post.getViewCount());
        dto.setLikeCount(post.getLikeCount());
        dto.setHeartCount(post.getHeartCount());
        dto.setBookmarkCount(post.getBookmarkCount());
        dto.setBannerImageKey(post.getBannerImageKey());
        dto.setCreatedAt(post.getCreatedAt());
        dto.setUpdatedAt(post.getUpdatedAt());
        dto.setScheduledPublishAt(post.getScheduledPublishAt());
        dto.setTags(post.getTags().stream().map(Tag::getName).collect(Collectors.toList()));

        if (resolveBannerUrl && post.getBannerImageKey() != null) {
            dto.setBannerImageUrl(constructS3Url(post.getBannerImageKey()));
        }

        return dto;
    }

    /**
     * Construct a stable public S3 URL, assuming your bucket allows public read.
     * Example: https://zblog-files.s3.eu-north-1.amazonaws.com/cover-images/abc.png
     */
    private String constructS3Url(String key) {
        return String.format("https://%s.s3.%s.amazonaws.com/%s", bucketName, awsRegion, key);
    }

    /**
     * Create or find Tag entities for the given list of tag names.
     */
    private Set<Tag> resolveTags(List<String> tagNames) {
        return tagNames.stream()
                .map(tagName -> tagRepository.findByNameIgnoreCase(tagName)
                        .orElseGet(() -> {
                            Tag newTag = new Tag();
                            newTag.setName(tagName);
                            return newTag;
                        }))
                .collect(Collectors.toSet());
    }

    @Override
    public Page<PostDTO> explorePosts(String keywords, List<String> tags, String sort, Pageable pageable, String currentUserId) {
        // Build a specification for filtering
        Specification<Post> spec = (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            // Only published posts or posts by the owner (if authenticated)
            if (currentUserId == null) {
                predicates.add(cb.isTrue(root.get("published")));
            } else {
                predicates.add(cb.or(
                        cb.isTrue(root.get("published")),
                        cb.equal(root.get("authorId"), currentUserId)
                ));
            }

            if (keywords != null && !keywords.isBlank()) {
                String kw = "%" + keywords.toLowerCase() + "%";
                predicates.add(cb.or(
                        cb.like(cb.lower(root.get("title")), kw),
                        cb.like(cb.lower(root.get("content")), kw)
                ));
            }

            if (tags != null && !tags.isEmpty()) {
                // Join to tags collection and match any of the provided tags (case-insensitive)
                predicates.add(root.join("tags").get("name").in(
                        tags.stream().map(String::toLowerCase).collect(Collectors.toList())
                ));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };

        // Remove any sorting from the incoming Pageable to avoid conflicts
        Pageable unsortedPageable = PageRequest.of(pageable.getPageNumber(), pageable.getPageSize());
        Page<Post> postPage = postRepository.findAll(spec, unsortedPageable);

        // Apply custom sorting in memory
        List<Post> sortedPosts = new ArrayList<>(postPage.getContent());
        switch (sort.toLowerCase()) {
            case "popular":
                sortedPosts.sort(Comparator.comparingLong(
                        p -> -(p.getLikeCount() + p.getHeartCount())
                ));
                break;
            case "mostliked":
                sortedPosts.sort(Comparator.comparingLong(
                        p -> -p.getLikeCount()
                ));
                break;
            case "recent":
            default:
                sortedPosts.sort(Comparator.comparing(Post::getCreatedAt, Comparator.nullsLast(Comparator.reverseOrder())));
                break;
        }

        // Map posts to DTOs (including generating a safe excerpt)
        List<PostDTO> dtos = sortedPosts.stream()
                .map(post -> mapToDTO(post, true))
                .collect(Collectors.toList());

        // Return a new PageImpl preserving the original pagination metadata.
        return new PageImpl<>(dtos, pageable, postPage.getTotalElements());
    }

    /**
     * Generates a safe excerpt from HTML content using Jsoup.
     */
    private String generateExcerpt(String htmlContent, int maxLength) {
        String text = Jsoup.clean(htmlContent, Safelist.none());
        if (text.length() > maxLength) {
            return text.substring(0, maxLength).trim() + "...";
        }
        return text;
    }

    @Override
    public PostDetailDTO getFullPost(UUID postId, String currentUserId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found"));

        // If post is unpublished, only the owner can view it
        if (!post.isPublished() && !post.getAuthorId().equals(currentUserId)) {
            throw new SecurityException("This post is unpublished and you are not the owner");
        }

        return mapToDetailDTO(post);
    }

    /**
     * Converts a Post entity into a full-detail DTO (without truncation).
     */
    private PostDetailDTO mapToDetailDTO(Post post) {
        PostDetailDTO dto = new PostDetailDTO();
        dto.setId(post.getId());
        dto.setAuthorId(post.getAuthorId());
        dto.setTitle(post.getTitle());
        // Return full content, not a truncated excerpt
        dto.setContent(post.getContent());
        dto.setPublished(post.isPublished());
        dto.setViewCount(post.getViewCount());
        dto.setLikeCount(post.getLikeCount());
        dto.setHeartCount(post.getHeartCount());
        dto.setBookmarkCount(post.getBookmarkCount());
        dto.setBannerImageKey(post.getBannerImageKey());
        dto.setCreatedAt(post.getCreatedAt());
        dto.setUpdatedAt(post.getUpdatedAt());
        dto.setScheduledPublishAt(post.getScheduledPublishAt());
        dto.setTags(post.getTags().stream().map(Tag::getName).collect(Collectors.toList()));

        if (post.getBannerImageKey() != null) {
            dto.setBannerImageUrl(constructS3Url(post.getBannerImageKey()));
        }
        return dto;
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/service/PostService.java -----
package com.zblog.zblogpostcore.service;

import com.zblog.zblogpostcore.dto.PostDTO;
import com.zblog.zblogpostcore.dto.PostDetailDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.UUID;

public interface PostService {
    PostDTO createPost(PostDTO postDTO, String currentUserId);
    PostDTO updatePost(UUID postId, PostDTO postDTO, String currentUserId);
    void deletePost(UUID postId, String currentUserId);

    PostDTO getPost(UUID postId, String currentUserId);
    Page<PostDTO> getAllPosts(boolean onlyPublished, Pageable pageable);
    Page<PostDTO> searchPosts(String keyword, boolean onlyPublished, Pageable pageable);
    Page<PostDTO> getPostsByAuthor(String authorId, boolean onlyPublished, Pageable pageable);

    PostDTO incrementViewCount(UUID postId);
    PostDTO reactToPost(UUID postId, String reactionType, String currentUserId);

    void validatePostExists(UUID postId);

    /**
     * Returns posts filtered by optional keywords and tags, sorted by the provided option.
     *
     * @param keywords      full-text keyword search (optional)
     * @param tags          list of tags to filter (optional)
     * @param sort          "recent", "popular", or "mostLiked"
     * @param pageable      pagination info
     * @param currentUserId current user (can be null for public)
     * @return a page of PostDTO results
     */
    Page<PostDTO> explorePosts(String keywords, List<String> tags, String sort, Pageable pageable, String currentUserId);

    /**
     * Returns the full post (with all content) for detail view.
     * This does not truncate the content.
     */
    PostDetailDTO getFullPost(UUID postId, String currentUserId);
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/ZblogPostCoreApplication.java -----
package com.zblog.zblogpostcore;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ZblogPostCoreApplication {

    public static void main(String[] args) {
        SpringApplication.run(ZblogPostCoreApplication.class, args);
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/domain/entity/Post.java -----
package com.zblog.zblogpostcore.domain.entity;

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

@Entity
@Table(name = "posts")
public class Post {

    @Id
    @GeneratedValue
    private UUID id;

    private String authorId;

    private String title;

    @Column(columnDefinition = "TEXT")
    private String content;

    private boolean published;

    private long viewCount;
    private long likeCount;
    private long heartCount;
    private long bookmarkCount;

    // Renamed from bannerImageFileId to bannerImageKey
    private String bannerImageKey;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;

    private Instant scheduledPublishAt;

    @ManyToMany(fetch = FetchType.LAZY, cascade = { CascadeType.PERSIST, CascadeType.MERGE })
    @JoinTable(name = "post_tags",
            joinColumns = @JoinColumn(name = "post_id"),
            inverseJoinColumns = @JoinColumn(name = "tag_id"))
    private Set<Tag> tags = new HashSet<>();

    // Getters and setters

    public UUID getId() {
        return id;
    }
    public void setId(UUID id) {
        this.id = id;
    }

    public String getAuthorId() {
        return authorId;
    }
    public void setAuthorId(String authorId) {
        this.authorId = authorId;
    }

    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }
    public void setContent(String content) {
        this.content = content;
    }

    public boolean isPublished() {
        return published;
    }
    public void setPublished(boolean published) {
        this.published = published;
    }

    public long getViewCount() {
        return viewCount;
    }
    public void setViewCount(long viewCount) {
        this.viewCount = viewCount;
    }

    public long getLikeCount() {
        return likeCount;
    }
    public void setLikeCount(long likeCount) {
        this.likeCount = likeCount;
    }

    public long getHeartCount() {
        return heartCount;
    }
    public void setHeartCount(long heartCount) {
        this.heartCount = heartCount;
    }

    public long getBookmarkCount() {
        return bookmarkCount;
    }
    public void setBookmarkCount(long bookmarkCount) {
        this.bookmarkCount = bookmarkCount;
    }

    public String getBannerImageKey() {
        return bannerImageKey;
    }
    public void setBannerImageKey(String bannerImageKey) {
        this.bannerImageKey = bannerImageKey;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }
    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }
    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Instant getScheduledPublishAt() {
        return scheduledPublishAt;
    }
    public void setScheduledPublishAt(Instant scheduledPublishAt) {
        this.scheduledPublishAt = scheduledPublishAt;
    }

    public Set<Tag> getTags() {
        return tags;
    }
    public void setTags(Set<Tag> tags) {
        this.tags = tags;
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/domain/entity/Tag.java -----
package com.zblog.zblogpostcore.domain.entity;

import jakarta.persistence.*;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "tags")
public class Tag {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @Column(unique = true, nullable = false)
    private String name;

    @ManyToMany(mappedBy = "tags", fetch = FetchType.LAZY)
    private List<Post> posts = new ArrayList<>();

    // Getters/Setters
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public List<Post> getPosts() { return posts; }
    public void setPosts(List<Post> posts) { this.posts = posts; }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/graphql/PostGraphQLController.java -----
package com.zblog.zblogpostcore.graphql;

import com.zblog.zblogpostcore.dto.PostDTO;
import com.zblog.zblogpostcore.service.PostService;
import com.zblog.zblogpostcore.util.SecurityUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.stereotype.Controller;

import java.util.UUID;

@Controller
public class PostGraphQLController {

    private final PostService postService;

    @Autowired
    public PostGraphQLController(PostService postService) {
        this.postService = postService;
    }

    @QueryMapping
    public PostDTO getPost(@Argument("id") UUID id) {
        String currentUserId = SecurityUtil.getCurrentUserIdOrNull();
        return postService.getPost(id, currentUserId);
    }

    @QueryMapping
    public Iterable<PostDTO> getAllPosts(@Argument("publishedOnly") boolean publishedOnly) {
        return postService.getAllPosts(publishedOnly, org.springframework.data.domain.PageRequest.of(0, 100));
    }

    @MutationMapping
    public PostDTO createPost(@Argument("postInput") PostDTO postInput) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        return postService.createPost(postInput, currentUserId);
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/exception/PostNotFoundException.java -----
package com.zblog.zblogpostcore.exception;

public class PostNotFoundException extends RuntimeException {
    public PostNotFoundException(String message) {
        super(message);
    }
}


----- /home/zakaria/zBlog/zblog-frontend/src/app/preview/page.tsx -----
"use client";

import React from "react";
import { useRouter } from "next/navigation";
import DOMPurify from "dompurify";
import { usePostDraft } from "@/context/PostDraftContext";
import PostDetail from "@/components/posts/PostDetail/PostDetail";

export default function PreviewPage() {
  const router = useRouter();
  const { draft } = usePostDraft();

  const safeContent = draft.content
    ? DOMPurify.sanitize(draft.content)
    : "<p>No content yet</p>";

  const post = {
    title: draft.title?.trim() || "Untitled Post",
    coverImageUrl: draft.coverImageUrl?.trim() || "/default-cover.jpg",
    content: safeContent,
    tags: draft.tags.length ? draft.tags : ["General"],
    publishedAt: new Date(),
    author: {
      name: "Preview Author",
      avatarUrl: "/avatars/default.png",
    },
  };

  return (
    <div className="bg-slate-900 text-white min-h-screen">
      {/* Back button */}
      <div className="p-4 border-b border-slate-800">
        <button
          onClick={() => router.push("/express")}
          className="px-4 py-2 bg-slate-800 hover:bg-slate-700 rounded text-white transition"
        >
          ← Back to Editor
        </button>
      </div>

      {/* Render PostPreview */}
      <PostDetail post={post} />
    </div>
  );
}


