----- /home/zakaria/zBlog/zblog-frontend/src/services/userService.ts -----
import axios, { AxiosError } from 'axios';

/**
 * Environment-based URL for the user-core service. Adjust as needed.
 * E.g. "https://api.example.com/user"
 */
const userCoreBaseURL =
  process.env.NEXT_PUBLIC_USER_CORE_URL ?? 'http://localhost:8080/user';

// ------------------
// Type Definitions
// ------------------

/** Matches Java: InitUserRequest */
export interface InitUserRequest {
  sub: string;
  username: string;
  email: string;
}

/** Represents the response from initUser (Map<String,Object>) */
export interface InitUserResponse {
  status: string;
  message: string;
  userId?: string;
}

/** Matches Java: UserProfileDTO */
export interface UserProfileDTO {
  username: string;
  displayName?: string;
  bio?: string;
  profileImageFileId?: string;
  profileImageUrl?: string;
  createdAt?: string;  // Instant -> string in JSON
  updatedAt?: string;  // Instant -> string in JSON
}

/** Matches Java: BookmarkDTO */
export interface BookmarkDTO {
  id: string;         // UUID -> string
  postId: string;     // UUID -> string
  createdAt: string;  // Instant -> string
}

// ---------------
// Utility Functions
// ---------------

/**
 * initUser: POST /user/internal/init-user
 * 
 * @param payload  Body of type InitUserRequest
 * @param providedSecret  Value for "X-Internal-Secret" header
 * @param authToken  Optional Bearer token
 */
export async function initUser(
  payload: InitUserRequest,
  providedSecret: string,
  authToken?: string
): Promise<InitUserResponse> {
  try {
    const url = `${userCoreBaseURL}/internal/init-user`;
    const res = await axios.post<InitUserResponse>(url, payload, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        'X-Internal-Secret': providedSecret,
        'Content-Type': 'application/json',
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * healthCheck: GET /user/health
 */
export async function getUserHealth(): Promise<string> {
  try {
    const url = `${userCoreBaseURL}/health`;
    const res = await axios.get<string>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * followUser: POST /user/api/follow/{targetUserId}
 */
export async function followUser(
  targetUserId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${userCoreBaseURL}/api/follow/${targetUserId}`;
    await axios.post<void>(
      url,
      {},
      {
        headers: {
          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        },
      }
    );
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * unfollowUser: DELETE /user/api/follow/{targetUserId}
 */
export async function unfollowUser(
  targetUserId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${userCoreBaseURL}/api/follow/${targetUserId}`;
    await axios.delete<void>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * createBookmark: POST /user/api/bookmarks/{postId}
 * returns BookmarkDTO
 */
export async function createBookmark(
  postId: string,
  authToken?: string
): Promise<BookmarkDTO> {
  try {
    const url = `${userCoreBaseURL}/api/bookmarks/${postId}`;
    const res = await axios.post<BookmarkDTO>(
      url,
      {},
      {
        headers: {
          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        },
      }
    );
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * removeBookmark: DELETE /user/api/bookmarks/{postId}
 */
export async function removeBookmark(
  postId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${userCoreBaseURL}/api/bookmarks/${postId}`;
    await axios.delete<void>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * listBookmarks: GET /user/api/bookmarks
 * 
 * Returns a "Page<BookmarkDTO>". For simplicity, we'll define a custom Paginated type.
 */
export interface Page<T> {
  content: T[];
  empty: boolean;
  first: boolean;
  last: boolean;
  number: number;
  size: number;
  totalElements: number;
  totalPages: number;
}

export async function listBookmarks(
  page: number,
  size: number,
  authToken?: string
): Promise<Page<BookmarkDTO>> {
  try {
    const url = `${userCoreBaseURL}/api/bookmarks?page=${page}&size=${size}`;
    const res = await axios.get<Page<BookmarkDTO>>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getUserProfile: GET /user/api/users/{userId}
 */
export async function getUserProfile(
  userId: string,
  authToken?: string
): Promise<UserProfileDTO> {
  try {
    const url = `${userCoreBaseURL}/api/users/${userId}`;
    const res = await axios.get<UserProfileDTO>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getMyProfile: GET /user/api/users/me
 */
export async function getMyProfile(authToken?: string): Promise<UserProfileDTO> {
  try {
    const url = `${userCoreBaseURL}/api/users/me`;
    const res = await axios.get<UserProfileDTO>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * updateMyProfile: PUT /user/api/users/me
 */
export async function updateMyProfile(
  profile: UserProfileDTO,
  authToken?: string
): Promise<UserProfileDTO> {
  try {
    const url = `${userCoreBaseURL}/api/users/me`;
    const res = await axios.put<UserProfileDTO>(url, profile, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// ---------------
// Error Handling
// ---------------
function handleAxiosError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const err = error as AxiosError;
    throw new Error(err.response?.data?.toString() || err.message);
  }
  throw error;
}


----- /home/zakaria/zBlog/zblog-frontend/src/services/postService.ts -----
import axios, { AxiosError } from 'axios';

const postCoreBaseURL =
  (process.env.NEXT_PUBLIC_POST_CORE_URL ?? 'http://localhost:8081/post').replace(/\/+$/, '');

  export interface PostDTO {
    id?: string;
    authorId?: string;
    title: string;
    content: string;
    published?: boolean;
    viewCount?: number;
    likeCount?: number;
    heartCount?: number;
    bookmarkCount?: number;
    bannerImageKey?: string;
    bannerImageUrl?: string;
    createdAt?: string;
    updatedAt?: string;
    scheduledPublishAt?: string;
    tags?: string[];
  }

// The Page<T> interface can be reused from userService (or define your own).
import { Page } from './userService';

/**
 * getPostHealth: GET /post/health
 */
export async function getPostHealth(): Promise<string> {
  try {
    const url = `${postCoreBaseURL}/health`;
    const res = await axios.get<string>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * Calls the new explore endpoint.
 */
export async function explorePosts(
  keywords: string,
  tags: string[],
  sort: "recent" | "popular" | "mostLiked",
  page: number,
  size: number,
  authToken?: string
): Promise<Page<PostDTO>> {
  const params = new URLSearchParams();
  if (keywords) params.append("keywords", keywords);
  if (tags.length > 0) params.append("tags", tags.join(","));
  params.append("sort", sort);
  params.append("page", page.toString());
  params.append("size", size.toString());

  const baseUrl = process.env.NEXT_PUBLIC_POST_CORE_URL?.replace(/\/+$/, "") || "";
  const url = `${baseUrl}/api/posts/explore?${params.toString()}`;

  const headers = authToken ? { Authorization: `Bearer ${authToken}` } : {};

  // 1. Fetch posts from explore endpoint
  const res = await axios.get<Page<PostDTO>>(url, { headers });

  // 2. Log visit to backend
  const visitUrl = `${baseUrl}/api/posts/visit`;
  try {
    await axios.post(
      visitUrl,
      {
        type: "explore_posts",
        keywords,
        tags,
        sort,
        page,
        size,
      },
      { headers }
    );
  } catch (e) {
    console.warn("Failed to log explore posts visit:", e);
  }

  return res.data;
}

// CREATE: POST /post/api/posts
export async function createPost(
  postDTO: PostDTO,
  authToken?: string
): Promise<PostDTO> {
  try {
    const url = `${postCoreBaseURL}/api/posts`;
    const res = await axios.post<PostDTO>(url, postDTO, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

export async function getPost(postId: string, authToken?: string): Promise<PostDTO> {
  const url = `${postCoreBaseURL}/api/posts/${postId}`;
  const res = await axios.get<PostDTO>(url, {
    headers: { ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}) },
  });
  return res.data;
}

// UPDATE: PUT /post/api/posts/{postId}
export async function updatePost(
  postId: string,
  postDTO: PostDTO,
  authToken?: string
): Promise<PostDTO> {
  try {
    const url = `${postCoreBaseURL}/api/posts/${postId}`;
    const res = await axios.put<PostDTO>(url, postDTO, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// DELETE: DELETE /post/api/posts/{postId}
export async function deletePost(
  postId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${postCoreBaseURL}/api/posts/${postId}`;
    await axios.delete<void>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
  } catch (error) {
    handleAxiosError(error);
  }
}

// LIST/PAGINATION: GET /post/api/posts?publishedOnly={true|false}&page=X&size=Y
export async function getAllPosts(
  publishedOnly: boolean,
  page: number,
  size: number,
  authToken?: string
): Promise<Page<PostDTO>> {
  const headers = authToken ? { Authorization: `Bearer ${authToken}` } : {};

  // 1. Fetch the posts
  const url = `${postCoreBaseURL}/api/posts?publishedOnly=${publishedOnly}&page=${page}&size=${size}`;
  const res = await axios.get<Page<PostDTO>>(url, { headers });

  // 2. Call /visit endpoint to log the event
  const visitUrl = `${postCoreBaseURL}/api/posts/visit`;
  try {
    await axios.post(visitUrl, {
      type: "view_all_posts",
      page,
      size,
      publishedOnly,
    }, { headers });
  } catch (e) {
    console.warn("Failed to log post list visit:", e);
  }

  return res.data;
}

// SEARCH: GET /post/api/posts/search?keyword=...&publishedOnly=...
export async function searchPosts(
  keyword: string,
  publishedOnly: boolean,
  page: number,
  size: number,
  authToken?: string
): Promise<Page<PostDTO>> {
  const url = `${postCoreBaseURL}/api/posts/search?keyword=${encodeURIComponent(
    keyword
  )}&publishedOnly=${publishedOnly}&page=${page}&size=${size}`;
  const res = await axios.get<Page<PostDTO>>(url, {
    headers: { ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}) },
  });
  return res.data;
}

// LIST BY AUTHOR: GET /post/api/posts/by-author/{authorId}?publishedOnly=...
export async function getPostsByAuthor(
  authorId: string,
  publishedOnly: boolean,
  page: number,
  size: number
): Promise<Page<PostDTO>> {
  try {
    const url = `${postCoreBaseURL}/api/posts/by-author/${authorId}?publishedOnly=${publishedOnly}&page=${page}&size=${size}`;
    const res = await axios.get<Page<PostDTO>>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// INCREMENT VIEW COUNT: PATCH /post/api/posts/{postId}/view
export async function incrementView(
  postId: string
): Promise<PostDTO> {
  try {
    const url = `${postCoreBaseURL}/api/posts/${postId}/view`;
    const res = await axios.patch<PostDTO>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// REACT: PATCH /post/api/posts/{postId}/react?type=like|heart|...
export async function react(
  postId: string,
  reactionType: string,
  authToken?: string
): Promise<PostDTO> {
  try {
    const url = `${postCoreBaseURL}/api/posts/${postId}/react?type=${reactionType}`;
    const res = await axios.patch<PostDTO>(
      url,
      {},
      {
        headers: {
          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        },
      }
    );
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// GET ALL TAGS: GET /post/api/tags
export async function getAllTags(authToken?: string): Promise<string[]> {
  try {
    const url = `${postCoreBaseURL}/api/tags`;
    const res = await axios.get<string[]>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}


// ---------------
// Error Handling
// ---------------
function handleAxiosError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const err = error as AxiosError;
    throw new Error(err.response?.data?.toString() || err.message);
  }
  throw error;
}


----- /home/zakaria/zBlog/zblog-frontend/src/services/authorCache.ts -----
import { getUserProfile } from './userService';

const authorNameCache = new Map<string, string>();

export function hasAuthor(id: string) {
  return authorNameCache.has(id);
}

export async function getAuthorName(authorId: string, authToken?: string): Promise<string> {
  if (authorNameCache.has(authorId)) {
    return authorNameCache.get(authorId)!;
  }

  try {
    const profile = await getUserProfile(authorId, authToken);
    const displayName = profile.displayName || profile.username || `User ${authorId.slice(0, 6)}`;
    authorNameCache.set(authorId, displayName);
    return displayName;
  } catch (err) {
    console.error(`Failed to fetch author for ${authorId}`, err);
    const fallback = `User ${authorId.slice(0, 6)}`;
    authorNameCache.set(authorId, fallback);
    return fallback;
  }
}


----- /home/zakaria/zBlog/zblog-frontend/src/services/s3Service.ts -----
import axios, { AxiosError } from 'axios';

const s3CoreBaseURL =
  process.env.NEXT_PUBLIC_S3_CORE_URL ?? 'http://localhost:8083/s3';

// Matches Java: S3FileMetadata
export interface S3FileMetadata {
  key: string;
  size: number;
  mimeType: string;
  uploadTimestamp: string;  // Instant -> string
  url: string;              // URL -> string
}

// GET /s3/health
export async function getS3Health(): Promise<string> {
  try {
    const url = `${s3CoreBaseURL}/health`;
    const res = await axios.get<string>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * uploadFile: POST /s3/files
 * 
 * @param file  the File/Blob
 * @param directory optional string for "directory" param (default "posts")
 * 
 * NOTE: In a browser, you’d typically need a FormData
 */
export async function uploadFile(
  file: File,
  directory = 'posts',
  authToken?: string
): Promise<S3FileMetadata> {
  const s3CoreBaseURL = (() => {
    const url = process.env.NEXT_PUBLIC_S3_CORE_URL;
    if (!url) throw new Error("Missing NEXT_PUBLIC_S3_CORE_URL");
    return url.replace(/\/+$/, ''); // strip trailing slash
  })();
  
  try {
    const url = `${s3CoreBaseURL}/files`;
    const formData = new FormData();
    formData.append('file', file);
    formData.append('directory', directory);

    const res = await axios.post<S3FileMetadata>(url, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getFileUrl: GET /s3/files/**?public=false
 * 
 * Java code slices the path after /internal/files/, 
 * but from a client standpoint, you’d typically do something like:
 * GET /s3/files/actualKey?public=false
 */
export async function getFileUrl(
  fileKey: string,
  isPublic = false,
  authToken?: string
): Promise<string> {
  try {
    const url = `${s3CoreBaseURL}/files/${fileKey}?public=${isPublic}`;
    const res = await axios.get<string>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getPresignedUploadUrl: GET /s3/files/{fileKey}/presign-upload
 */
export async function getPresignedUploadUrl(
  fileKey: string,
  authToken?: string
): Promise<string> {
  try {
    const url = `${s3CoreBaseURL}/files/${fileKey}/presign-upload`;
    const res = await axios.get<string>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * deleteFile: DELETE /s3/files/** 
 */
export async function deleteFile(fileKey: string, authToken?: string): Promise<string> {
  try {
    const url = `${s3CoreBaseURL}/files/${fileKey}`;
    const res = await axios.delete<string>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * listFiles: GET /s3/files?prefix=someFolder/
 */
export async function listFiles(prefix: string, authToken?: string): Promise<S3FileMetadata[]> {
  try {
    const url = `${s3CoreBaseURL}/files?prefix=${encodeURIComponent(prefix)}`;
    const res = await axios.get<S3FileMetadata[]>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// ---------------
// Error Handling
// ---------------
function handleAxiosError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const err = error as AxiosError;
    throw new Error(err.response?.data?.toString() || err.message);
  }
  throw error;
}


----- /home/zakaria/zBlog/zblog-frontend/src/services/commentService.ts -----
import axios, { AxiosError } from 'axios';
import { Page } from '@/services/userService'; // or define again

const commentCoreBaseURL =
  process.env.NEXT_PUBLIC_COMMENT_CORE_URL ?? 'http://localhost:8082/comment';

// From your DTOs:

export interface CommentCreateRequest {
  postId: string;
  parentId?: string;
  content: string;
  attachmentFileId?: string;
}

export interface CommentUpdateRequest {
  id: string;
  content: string;
  attachmentFileId?: string;
}

export interface CommentResponseDTO {
  id: string;
  postId: string;
  authorId: string;
  content: string;
  createdAt: string;
  updatedAt: string;
  parentId?: string;
  likeCount: number;
  laughCount: number;
  sadCount: number;
  insightfulCount: number;
  replies?: CommentResponseDTO[];
  attachmentFileId?: string;
  attachmentFileUrl?: string;
}

/**
 * commentHealthCheck: GET /comment/health
 */
export async function getCommentHealth(): Promise<string> {
  try {
    const url = `${commentCoreBaseURL}/health`;
    const res = await axios.get<string>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * createComment: POST /comment/api/comments
 */
export async function createComment(
  data: CommentCreateRequest,
  authToken?: string
): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments`;
    const res = await axios.post<CommentResponseDTO>(url, data, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * updateComment: PUT /comment/api/comments/{commentId}
 */
export async function updateComment(
  commentId: string,
  data: CommentUpdateRequest,
  authToken?: string
): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}`;
    const res = await axios.put<CommentResponseDTO>(url, data, {
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * deleteComment: DELETE /comment/api/comments/{commentId}
 */
export async function deleteComment(
  commentId: string,
  authToken?: string
): Promise<void> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}`;
    await axios.delete<void>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getTopLevelComments: GET /comment/api/comments/post/{postId}?page=X&size=Y
 */
export async function getTopLevelComments(
  postId: string,
  page: number,
  size: number,
  authToken?: string
): Promise<Page<CommentResponseDTO>> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/post/${postId}?page=${page}&size=${size}`;
    const res = await axios.get<Page<CommentResponseDTO>>(url, {
      headers: {
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
    });
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getComment: GET /comment/api/comments/{commentId}
 */
export async function getComment(commentId: string): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}`;
    const res = await axios.get<CommentResponseDTO>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * getCommentThread: GET /comment/api/comments/{commentId}/thread
 */
export async function getCommentThread(
  commentId: string
): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}/thread`;
    const res = await axios.get<CommentResponseDTO>(url);
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

/**
 * toggleReaction: PATCH /comment/api/comments/{commentId}/react?type=like|laugh|sad|insightful
 */
export async function toggleReaction(
  commentId: string,
  reactionType: string,
  authToken?: string
): Promise<CommentResponseDTO> {
  try {
    const url = `${commentCoreBaseURL}/api/comments/${commentId}/react?type=${reactionType}`;
    const res = await axios.patch<CommentResponseDTO>(
      url,
      {},
      {
        headers: {
          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
        },
      }
    );
    return res.data;
  } catch (error) {
    handleAxiosError(error);
  }
}

// ---------------
// Error Handling
// ---------------
function handleAxiosError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const err = error as AxiosError;
    throw new Error(err.response?.data?.toString() || err.message);
  }
  throw error;
}


----- /home/zakaria/zBlog/zblog-frontend/src/providers/QueryProvider.tsx -----
"use client"

import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { ReactNode, useState } from "react"

export default function QueryProvider({ children }: { children: ReactNode }) {
  const [client] = useState(() => new QueryClient())

  return <QueryClientProvider client={client}>{children}</QueryClientProvider>
}


----- /home/zakaria/zBlog/zblog-frontend/src/providers/CognitoProvider.tsx -----
"use client"

import { AuthProvider } from "react-oidc-context";
import { cognitoConfig } from "@/lib/cognitoConfig";

export default function CognitoProvider({ children }: { children: React.ReactNode }) {
  return <AuthProvider {...cognitoConfig}>{children}</AuthProvider>;
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/comment/useCreateComment.ts -----
import { useState } from 'react';
import { useAuth } from 'react-oidc-context';
import {
  createComment,
  CommentCreateRequest,
  CommentResponseDTO,
} from '@/services/commentService';

interface UseCreateComment {
  create: (req: CommentCreateRequest) => Promise<CommentResponseDTO | undefined>;
  loading: boolean;
  error?: string;
}

export function useCreateComment(): UseCreateComment {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();
  const auth = useAuth();

  async function create(
    req: CommentCreateRequest
  ): Promise<CommentResponseDTO | undefined> {
    const token = auth.user?.access_token;

    if (!token) {
      setError("You must be logged in to comment.");
      return undefined;
    }

    try {
      setLoading(true);
      setError(undefined);
      const result = await createComment(req, token);
      return result;
    } catch (err: any) {
      setError(err.message || 'Error creating comment');
      return undefined;
    } finally {
      setLoading(false);
    }
  }

  return { create, loading, error };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/comment/useToggleCommentReaction.ts -----
import { useState } from "react";
import { toggleReaction } from "@/services/commentService";
import { CommentResponseDTO } from "@/services/commentService";

export function useToggleCommentReaction() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  const toggle = async (
    commentId: string,
    reactionType: string,
    token: string
  ): Promise<CommentResponseDTO | undefined> => {
    try {
      setLoading(true);
      setError(undefined);
      const updatedComment = await toggleReaction(commentId, reactionType, token);
      return updatedComment;
    } catch (err: any) {
      setError(err.message || "Error toggling reaction");
      return undefined;
    } finally {
      setLoading(false);
    }
  };

  return { toggle, loading, error };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/comment/useComments.ts -----
import { useInfiniteQuery } from "@tanstack/react-query";
import { getTopLevelComments } from "@/services/commentService";
import { useAuth } from "react-oidc-context";

export function useComments(postId: string) {
  const auth = useAuth();
  const token = auth.user?.access_token;

  const {
    data,
    fetchNextPage,
    isLoading,
    hasNextPage,
  } = useInfiniteQuery({
    queryKey: ["comments", postId],
    queryFn: ({ pageParam = 0 }) =>
      getTopLevelComments(postId, pageParam, 10, token),
    initialPageParam: 0,
    getNextPageParam: (lastPage) =>
      lastPage.last ? undefined : lastPage.number + 1,
    enabled: !!postId && !!token,
  });

  const comments = data?.pages.flatMap((page) => page.content) ?? [];

  return {
    comments,
    hasNextPage: hasNextPage ?? false,
    fetchNextPage: fetchNextPage ?? (() => {}),
    isLoading,
  };
}



----- /home/zakaria/zBlog/zblog-frontend/src/hooks/post/useCreatePost.ts -----
"use client";

import { useState } from "react";
import { createPost, PostDTO } from "@/services/postService";

/**
 * A custom hook to create a post via post-core service.
 */
export function useCreatePost() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  /**
   * create: Calls the createPost() service method. 
   * Pass `authToken` (e.g. from Cognito).
   */
  async function create(post: PostDTO, authToken?: string) {
    try {
      setLoading(true);
      setError(null);

      const newPost = await createPost(post, authToken);
      return newPost;
    } catch (err: any) {
      setError(err.message || "Failed to create post");
      return null;
    } finally {
      setLoading(false);
    }
  }

  return {
    create,
    loading,
    error,
  };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/post/useTogglePostReaction.ts -----
import { useState } from "react";
import { react } from "@/services/postService";
import { PostDTO } from "@/services/postService";

export function useTogglePostReaction() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  const toggle = async (
    postId: string,
    reactionType: string,
    token: string
  ): Promise<PostDTO | undefined> => {
    try {
      setLoading(true);
      setError(undefined);
      const updatedPost = await react(postId, reactionType, token);
      return updatedPost;
    } catch (err: any) {
      setError(err.message || "Error toggling post reaction");
      return undefined;
    } finally {
      setLoading(false);
    }
  };

  return { toggle, loading, error };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/post/useGetPost.ts -----
import { useEffect, useState } from 'react';
import { getPost, PostDTO } from '@/services/postService';

interface UseGetPostReturn {
  data?: PostDTO;
  error?: string;
  loading: boolean;
  refetch: () => void;
}

export function useGetPost(postId: string, authToken?: string): UseGetPostReturn {
  const [data, setData] = useState<PostDTO | undefined>(undefined);
  const [error, setError] = useState<string | undefined>(undefined);
  const [loading, setLoading] = useState<boolean>(true);

  const fetchPost = async () => {
    try {
      setLoading(true);
      const result = await getPost(postId, authToken);
      setData(result);
      setError(undefined);
    } catch (err: any) {
      setError(err.message || 'Error fetching post');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (postId) {
      fetchPost();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [postId]);

  return {
    data,
    error,
    loading,
    refetch: fetchPost,
  };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/user/useInitUser.ts -----
import { useState } from 'react';
import { initUser, InitUserRequest, InitUserResponse } from '@/services/userService';

interface UseInitUser {
  init: (payload: InitUserRequest, secret: string, token?: string) => Promise<InitUserResponse | undefined>;
  loading: boolean;
  error: string | null;
}

export function useInitUser(): UseInitUser {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function init(
    payload: InitUserRequest,
    secret: string,
    token?: string
  ): Promise<InitUserResponse | undefined> {
    try {
      setLoading(true);
      setError(null);
      const response = await initUser(payload, secret, token);
      return response;
    } catch (err: any) {
      setError(err.message || 'Failed to init user');
      return undefined;
    } finally {
      setLoading(false);
    }
  }

  return { init, loading, error };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/s3/useUploadFile.ts -----
import { useState } from 'react';
import { uploadFile, S3FileMetadata } from '@/services/s3Service';

export interface UploadResult {
  previewUrl: string;
  fileKey: string;
}

interface UseUploadFile {
  upload: (file: File, directory?: string, token?: string) => Promise<UploadResult | undefined>;
  loading: boolean;
  error?: string;
}

export function useUploadFile(): UseUploadFile {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  async function upload(
    file: File,
    directory?: string,
    token?: string
  ): Promise<UploadResult | undefined> {
    try {
      setLoading(true);
      setError(undefined);
      const data: S3FileMetadata = await uploadFile(file, directory, token);
      // Return an object with both previewUrl and fileKey
      return { previewUrl: data.url.toString(), fileKey: data.key };
    } catch (err: any) {
      setError(err.message || 'File upload failed');
      return undefined;
    } finally {
      setLoading(false);
    }
  }

  return {
    upload,
    loading,
    error,
  };
}


----- /home/zakaria/zBlog/zblog-frontend/src/hooks/drafts/useDraftManager.ts -----
"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import { usePathname } from "next/navigation";
import debounce from "lodash.debounce";

export interface DraftData {
  title: string;
  content: string;
  tags: string[];
  coverImageUrl: string;
  coverImageKey: string;
}

const DRAFT_VERSION = 2;

export function useDraftManager({
  userId,
  contentType,
}: {
  userId?: string | null;
  contentType: string;
}) {
  const pathname = usePathname();
  const effectiveUserId = userId ?? "guest";

  const DRAFT_STORAGE_KEY = `zblog_${contentType}_draft_v${DRAFT_VERSION}_${effectiveUserId}`;
  const DISCARD_FLAG_KEY = `zblog_${contentType}_discarded_v${DRAFT_VERSION}_${effectiveUserId}`;

  const [draft, setDraft] = useState<DraftData>({
    title: "",
    content: "",
    tags: [],
    coverImageUrl: "",
    coverImageKey: "",
  });
  const [hasChanges, setHasChanges] = useState(false);
  const [showResumeModal, setShowResumeModal] = useState(false);
  const [autoSaveStatus, setAutoSaveStatus] = useState("No changes");

  // Refs to control prompting and re‑loading
  const hasPromptedRef = useRef(false);
  const shouldReloadDraftRef = useRef(true);

  // Utility: Check if a draft is empty.
  const isDraftEmpty = useCallback((d: DraftData) => {
    return (
      !d.title &&
      !d.content &&
      !d.coverImageUrl &&
      !d.coverImageKey &&
      (!d.tags || d.tags.length === 0)
    );
  }, []);

  // Utility: Load a draft from localStorage.
  const loadLocalDraft = useCallback((): DraftData | null => {
    const raw = localStorage.getItem(DRAFT_STORAGE_KEY);
    if (!raw) return null;
    try {
      return JSON.parse(raw) as DraftData;
    } catch {
      localStorage.removeItem(DRAFT_STORAGE_KEY);
      return null;
    }
  }, [DRAFT_STORAGE_KEY]);

  // Utility: Clear draft from state and storage.
  const clearAllDraftData = useCallback(() => {
    localStorage.removeItem(DRAFT_STORAGE_KEY);
    localStorage.removeItem(DISCARD_FLAG_KEY);
    setDraft({
      title: "",
      content: "",
      tags: [],
      coverImageUrl: "",
      coverImageKey: "",
    });
    setHasChanges(false);
    setAutoSaveStatus("No changes");
  }, [DRAFT_STORAGE_KEY, DISCARD_FLAG_KEY]);

  // --- Draft Loading Effect ---
  useEffect(() => {
    if (!shouldReloadDraftRef.current) return;

    const discardFlag = localStorage.getItem(DISCARD_FLAG_KEY);
    if (discardFlag === "true") {
      clearAllDraftData();
      shouldReloadDraftRef.current = false;
      return;
    }

    const existingDraft = loadLocalDraft();
    if (existingDraft) {
      setDraft(existingDraft);
      if (pathname === "/express" && !hasPromptedRef.current) {
        setShowResumeModal(true);
        hasPromptedRef.current = true;
      }
    }
    shouldReloadDraftRef.current = false;
  }, [pathname, loadLocalDraft, clearAllDraftData]);

  // When leaving the create page, reset our flags so that on return the draft reloads.
  useEffect(() => {
    if (pathname !== "/express") {
      hasPromptedRef.current = false;
      shouldReloadDraftRef.current = true;
    }
  }, [pathname]);

  // --- Resume / Discard Handlers ---
  const handleResumeDraft = useCallback(() => {
    setShowResumeModal(false);
    // Mark unsaved changes so that auto-save continues.
    setHasChanges(true);
  }, []);

  const handleDiscardLocalDraft = useCallback(() => {
    localStorage.setItem(DISCARD_FLAG_KEY, "true");
    clearAllDraftData();
    setShowResumeModal(false);
  }, [clearAllDraftData]);

  // --- Auto-save ---
  // Save draft to storage regardless of whether it's "empty"
  const saveDraftToStorage = useCallback((nextDraft: DraftData) => {
    localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(nextDraft));
    setAutoSaveStatus("Saved just now");
  }, [DRAFT_STORAGE_KEY]);

  const debouncedSave = useRef(
    debounce((nextDraft: DraftData) => {
      setAutoSaveStatus("Saving...");
      saveDraftToStorage(nextDraft);
    }, 800)
  ).current;

  useEffect(() => {
    if (!hasChanges) return;
    debouncedSave(draft);
    return () => debouncedSave.cancel();
  }, [draft, hasChanges, debouncedSave]);

  // --- Navigation Warning ---
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (hasChanges && !isDraftEmpty(draft)) {
        e.preventDefault();
        e.returnValue = "";
      }
    };
    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => window.removeEventListener("beforeunload", handleBeforeUnload);
  }, [hasChanges, draft, isDraftEmpty]);

  useEffect(() => {
    const handlePopState = () => {
      if (hasChanges && !isDraftEmpty(draft)) {
        const shouldLeave = window.confirm(
          "You have unsaved changes. Are you sure you want to leave?"
        );
        if (!shouldLeave) {
          window.history.pushState(null, "", window.location.href);
          return false;
        }
      }
      return true;
    };
    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, [hasChanges, draft, isDraftEmpty]);

  // --- Public Methods ---
  const setDraftField = useCallback(
    <K extends keyof DraftData>(field: K, value: DraftData[K]) => {
      setDraft((prev) => ({ ...prev, [field]: value }));
      setHasChanges(true);
    },
    []
  );

  const handleDiscardFromEditor = useCallback(() => {
    if (isDraftEmpty(draft) && !hasChanges) return;
    if (!window.confirm("Discard all changes? This cannot be undone.")) return;
    localStorage.setItem(DISCARD_FLAG_KEY, "true");
    clearAllDraftData();
  }, [draft, hasChanges, isDraftEmpty, clearAllDraftData]);

  const clearDraft = useCallback(() => {
    clearAllDraftData();
  }, [clearAllDraftData]);

  return {
    draft,
    setDraftField,
    hasChanges,
    autoSaveStatus,
    showResumeModal,
    handleResumeDraft,
    handleDiscardLocalDraft,
    handleDiscardFromEditor,
    clearDraft,
  };
}


----- /home/zakaria/zBlog/zblog-frontend/src/context/PostDraftContext.tsx -----
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";

interface PostDraft {
  title: string;
  tags: string[];
  coverImageUrl: string;  // ephemeral or public URL for immediate preview
  coverImageKey: string;  // the S3 key stored for back-end (bannerImageKey)
  content: string;
}

interface PostDraftContextValue {
  draft: PostDraft;
  setDraft: React.Dispatch<React.SetStateAction<PostDraft>>;
  resetDraft: () => void;
}

const defaultDraft: PostDraft = {
  title: "",
  tags: [],
  coverImageUrl: "",
  coverImageKey: "",
  content: "",
};

const PostDraftContext = createContext<PostDraftContextValue | undefined>(undefined);

export function PostDraftProvider({ children }: { children: ReactNode }) {
  const [draft, setDraft] = useState<PostDraft>(defaultDraft);

  function resetDraft() {
    setDraft(defaultDraft);
  }

  return (
    <PostDraftContext.Provider value={{ draft, setDraft, resetDraft }}>
      {children}
    </PostDraftContext.Provider>
  );
}

export function usePostDraft() {
  const context = useContext(PostDraftContext);
  if (!context) {
    throw new Error("usePostDraft must be used within a PostDraftProvider");
  }
  return context;
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/Fallback/Fallback.tsx -----
import React from 'react';
import Lottie from 'lottie-react';
import loadingAnimation from '@/assets/animations/loadingAnimation.json';
import '@/styles/Fallback.css'; 

interface FallbackProps {
  message: string;
}

const Fallback: React.FC<FallbackProps> = ({ message }) => {
  return (
    <div className="fallback-wrapper">
      <div className="fallback-inner">
        <Lottie animationData={loadingAnimation} loop className="fallback-animation" />
        <p className="fallback-message">{message}</p>
      </div>
    </div>
  );
};

export default Fallback;


----- /home/zakaria/zBlog/zblog-frontend/src/components/Fallback/ErrorBoundary.tsx -----
"use client";

import React from "react";

type Props = {
  children: React.ReactNode;
  fallback: React.ReactNode;
};

type State = {
  hasError: boolean;
};

export default class ErrorBoundary extends React.Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(_: Error): State {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) return this.props.fallback;
    return this.props.children;
  }
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/tags/TagCard.tsx -----
'use client'

import React from "react"
import Image from "next/image"
import { motion } from "framer-motion"

export interface TagCardProps {
  title: string
  image: string
  description?: string
  onClick?: () => void
}

export default function TagCard({ title, image, description, onClick }: TagCardProps) {
  return (
    <motion.div
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={onClick}
      className="relative h-64 w-full rounded-xl shadow-md cursor-pointer overflow-hidden border border-slate-700"
    >
      {/* Background Image */}
      <Image
        src={image}
        alt={title}
        fill
        className="object-cover object-center brightness-75"
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      />

      {/* Dark overlay for neon contrast */}
      <div className="absolute inset-0 bg-black/40" />

      {/* Tag title and optional description */}
      <div className="relative z-10 flex flex-col items-center justify-center text-center h-full px-4">
        <h3 className="text-white text-2xl font-bold mb-2 neon-text">
          #{title}
        </h3>
        {description && (
          <p className="text-gray-200 text-sm max-w-xs">{description}</p>
        )}
      </div>
    </motion.div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/tags/NoTagsHolder.tsx -----
'use client'

import React from 'react'
import { motion } from 'framer-motion'
import Lottie from 'lottie-react'
import emptyBoxAnimation from '@/assets/animations/empty-state.json'

export default function NoTagsHolder() {
  return (
    <main className="min-h-screen flex items-center justify-center bg-slate-900 px-6 py-20 text-white">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="w-full max-w-2xl p-8 text-center neon-glow-box"
      >
        <div className="w-40 h-40 mx-auto mb-6 opacity-90">
          <Lottie animationData={emptyBoxAnimation} loop autoplay />
        </div>

        <h2 className="text-cyan-400 text-2xl font-bold uppercase tracking-wider mb-2">
          No Tags Found
        </h2>
        <p className="text-slate-400 text-sm max-w-md mx-auto">
          Looks like there are no topics available yet. Once posts are tagged,
          they’ll appear here automatically.
        </p>
      </motion.div>
    </main>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/HeroSection.tsx -----
"use client"

import { motion } from "framer-motion"
import Link from "next/link"
import { useEffect } from "react"
import { useAuth } from "react-oidc-context"

export interface HeroSectionProps {
  title?: string
  subtitle?: string
  buttonText?: string
}

export default function HeroSection({
  title = "Write posts on multiple topics",
  subtitle = "Create and organize posts with images, videos, code snippets, and more. Execute live code, share your thoughts, and explore new ideas.",
  buttonText = "Join Now",
}: HeroSectionProps) {

  const auth = useAuth()

  useEffect(() => {
    if (auth.isAuthenticated && auth.user) {
      const token = auth.user.access_token
      console.log("Authorization Header:", `Bearer ${token}`)
    }
  }, [auth.isAuthenticated, auth.user])

  
  return (
    <section className="relative overflow-hidden">
      {/* Background decorative elements */}
      <div className="absolute inset-0 -z-10">
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          transition={{ duration: 1, ease: "easeOut" }}
          className="absolute top-0 left-0 w-72 h-72 bg-slate-500/10 rounded-full filter blur-3xl"
        />
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          transition={{ duration: 1, delay: 0.2, ease: "easeOut" }}
          className="absolute bottom-0 right-0 w-72 h-72 bg-slate-600/10 rounded-full filter blur-3xl"
        />
      </div>

      <div className="flex flex-col md:flex-row items-center gap-12 py-16">
        <motion.div
          initial={{ opacity: 0, x: -50 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ type: "spring", stiffness: 80, damping: 12, delay: 0.2 }}
          className="md:w-1/2 space-y-6"
        >
          <h1 className="text-4xl md:text-6xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-slate-200 to-slate-400">
            {title}
          </h1>
          <p className="text-slate-400 text-lg md:text-xl max-w-xl">{subtitle}</p>
          {/* Button Animation: transform origin set to center */}
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.6, ease: "easeOut", delay: 0.5 }}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            style={{ originX: 0.5, originY: 0.5 }}
            className="inline-block ml-6"
          >
            <Link href="/register" className="inline-block">
              <button className="px-8 py-4 bg-gradient-to-r from-slate-700 to-slate-800 hover:from-slate-600 hover:to-slate-700 text-slate-200 rounded-lg font-medium shadow-xl transition-all hover:shadow-slate-500/20">
                {buttonText}
              </button>
            </Link>
          </motion.div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, x: 50 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ type: "spring", stiffness: 80, damping: 12, delay: 0.4 }}
          className="md:w-1/2"
        >
          <div className="relative">
            <motion.div
              initial={{ scale: 0.95, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              transition={{ duration: 0.8, delay: 0.5 }}
              className="absolute inset-0 bg-gradient-to-r from-slate-800 to-slate-700 rounded-2xl transform rotate-6 opacity-40 blur-xl"
            />
            <div className="relative bg-gradient-to-r from-slate-800 to-slate-700 p-8 rounded-2xl shadow-2xl">
            <div className="h-64 flex items-center justify-center">
              <motion.img
                src="/images/hero-preview.png"
                alt="Premium Content Preview"
                className="max-h-full object-contain"
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                transition={{ duration: 0.8, delay: 0.6 }}
              />
            </div>
            </div>
          </div>
        </motion.div>
      </div>
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/PostsSection.tsx -----
"use client"

import Link from "next/link"
import { motion } from "framer-motion"

export interface Post {
  id: number
  title: string
  excerpt: string
  date: string
  image?: string
}

const defaultPosts: Post[] = [
  {
    id: 1,
    title: "Understanding Microservices",
    excerpt: "A deep dive into microservices architecture and best practices.",
    date: "2025-03-01",
    image: "https://picsum.photos/300/200?random=1",
  },
  {
    id: 2,
    title: "Mastering Next.js",
    excerpt: "Learn how to build fast, scalable web apps with Next.js.",
    date: "2025-03-05",
    image: "https://picsum.photos/300/200?random=2",
  },
  {
    id: 3,
    title: "Frontend Animations with Framer Motion",
    excerpt: "Bring your UI to life with smooth and interactive animations.",
    date: "2025-03-10",
    image: "https://picsum.photos/300/200?random=3",
  },
]

export default function PostsSection({ posts = defaultPosts }: { posts?: Post[] }) {
  return (
    <section className="py-12">
      <h2 className="text-2xl font-bold mb-6 text-slate-100">Latest Posts</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {posts.map((post) => (
          <motion.div
            key={post.id}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ type: "spring", stiffness: 80, damping: 12, delay: post.id * 0.2 }}
            className="bg-slate-800 border border-slate-700 rounded-lg shadow-md overflow-hidden"
          >
            {post.image && (
              <img
                src={post.image}
                alt={post.title}
                className="w-full h-40 object-cover"
              />
            )}
            <div className="p-4">
              <h3 className="font-semibold text-slate-100">{post.title}</h3>
              <p className="text-slate-400 text-sm">{post.excerpt}</p>
              <p className="text-slate-500 text-xs mt-2">{post.date}</p>
              <Link
                href={`/posts/${post.id}`}
                className="mt-2 inline-block text-blue-400 hover:underline"
              >
                Read More
              </Link>
            </div>
          </motion.div>
        ))}
      </div>
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/ArticlesSection.tsx -----
"use client"

import { motion } from "framer-motion"

export interface Article {
  id: number
  title: string
  summary: string
  image?: string
}

const defaultArticles: Article[] = [
  {
    id: 1,
    title: "Article on UI Design",
    summary: "Tips and tricks for modern, responsive UI design.",
    image: "https://picsum.photos/300/200?random=4",
  },
  {
    id: 2,
    title: "Understanding Auth Flows",
    summary: "A comprehensive guide to authentication in web apps.",
    image: "https://picsum.photos/300/200?random=5",
  },
  {
    id: 3,
    title: "Deploying with Kubernetes",
    summary: "Step-by-step instructions for container orchestration.",
    image: "https://picsum.photos/300/200?random=6",
  },
]

export default function ArticlesSection({
  articles = defaultArticles,
}: {
  articles?: Article[]
}) {
  return (
    <section className="py-12">
      <h2 className="text-2xl font-bold mb-6 text-slate-100">Seat Articles</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {articles.map((article) => (
          <motion.div
            key={article.id}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ type: "spring", stiffness: 80, damping: 12, delay: article.id * 0.2 }}
            className="bg-slate-800 border border-slate-700 rounded-lg shadow-md overflow-hidden"
          >
            {article.image && (
              <img
                src={article.image}
                alt={article.title}
                className="w-full h-40 object-cover"
              />
            )}
            <div className="p-4">
              <h3 className="font-semibold text-slate-100">{article.title}</h3>
              <p className="text-slate-400 text-sm">{article.summary}</p>
            </div>
          </motion.div>
        ))}
      </div>
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/FeaturesSection.tsx -----
"use client"

import FeatureCard from "./FeatureCard"
import { FileText, TerminalSquare, Server } from "lucide-react"

export interface Feature {
  id: number
  title: string
  description: string
  icon?: React.ReactNode
}

const defaultFeatures: Feature[] = [
  {
    id: 1,
    title: "Create rich posts",
    description: "Write and organize content with images, videos, and more.",
    icon: <FileText className="w-12 h-12 text-slate-300" />,
  },
  {
    id: 2,
    title: "Code snippets",
    description: "Showcase your code snippets directly in your posts.",
    icon: <TerminalSquare className="w-12 h-12 text-slate-300" />,
  },
  {
    id: 3,
    title: "Share your thoughts",
    description: "Engage with an audience and share your expertise.",
    icon: <Server className="w-12 h-12 text-slate-300" />,
  },
]

export default function FeaturesSection({
  features = defaultFeatures,
}: {
  features?: Feature[]
}) {
  return (
    <section className="grid grid-cols-1 md:grid-cols-3 gap-8 py-12">
      {features.map((feature) => (
        <FeatureCard
          key={feature.id}
          title={feature.title}
          description={feature.description}
          icon={feature.icon}
        />
      ))}
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/FeatureCard.tsx -----
"use client"

import React from "react"
import { FileText, TerminalSquare, Server } from "lucide-react"
import { motion } from "framer-motion"

export interface FeatureCardProps {
  title: string
  description: string
  icon?: React.ReactNode
}

export default function FeatureCard({
  title,
  description,
  icon,
}: FeatureCardProps) {
  return (
    <motion.div
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
      className="flex flex-col items-center text-center p-6 border border-slate-700 rounded-lg shadow-md bg-slate-800"
      transition={{ type: "spring", stiffness: 100, damping: 10 }}
    >
      <div className="mb-4">
        {icon ? (
          icon
        ) : (
          <FileText className="w-12 h-12 text-slate-300" />
        )}
      </div>
      <h3 className="font-semibold text-slate-100 mb-2">{title}</h3>
      <p className="text-slate-400 text-sm">{description}</p>
    </motion.div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/AnimatedBackground.tsx -----
"use client"

import { useCallback } from "react"
import Particles from "react-tsparticles"
import { loadSlim } from "tsparticles-slim" 

export default function AnimatedBackground() {
  const particlesInit = useCallback(async (engine: any) => {
    await loadSlim(engine)
  }, [])

  return (
    <Particles
      id="tsparticles"
      init={particlesInit}
      options={{
        fullScreen: { enable: true, zIndex: -1 },
        background: {
          color: { value: "#0f172a" },
        },
        fpsLimit: 60,
        interactivity: {
          events: {
            onHover: { enable: true, mode: "repulse" },
            resize: true,
          },
          modes: {
            repulse: { distance: 100, duration: 0.4 },
          },
        },
        particles: {
          color: { value: "#3b82f6" },
          links: {
            color: "#3b82f6",
            distance: 150,
            enable: true,
            opacity: 0.3,
            width: 1,
          },
          collisions: { enable: true },
          move: {
            direction: "none",
            enable: true,
            outModes: { default: "bounce" },
            speed: 1,
          },
          number: { value: 50, density: { enable: true, area: 800 } },
          opacity: { value: 0.5 },
          shape: { type: "circle" },
          size: { value: { min: 1, max: 4 } },
        },
        detectRetina: true,
      }}
    />
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/landingPage/Navbar.tsx -----
"use client"

import React, { useState, useEffect } from "react"
import Link from "next/link"
import { useAuth } from "react-oidc-context"
import { Search, UserCircle, MoreHorizontal } from "lucide-react"
import { motion } from "framer-motion"
import Lottie from "lottie-react"
import zLogoAnimation from "@/assets/animations/z-logo.json"

export default function Navbar() {
  const auth = useAuth()

  const [location, setLocation] = useState<string>("Fetching location...")
  const [temperature, setTemperature] = useState<string>("Fetching temperature...")
  const [time, setTime] = useState<string>("Fetching time...")
  const [isSearchOpen, setIsSearchOpen] = useState<boolean>(false)
  const [isProfileDropdownOpen, setIsProfileDropdownOpen] = useState<boolean>(false)
  const [isAvatarHovered, setIsAvatarHovered] = useState<boolean>(false)

  const navItems = [
    { label: "Recent", href: "/recent" },
    { label: "Tags", href: "/tags" },
    { label: "Explore", href: "/posts" },
    ...(auth.isAuthenticated ? [{ label: "Express", href: "/express" }] : []),
    { label: "About", href: "/about" },
  ]  

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (isProfileDropdownOpen) {
        const target = event.target as HTMLElement
        if (!target.closest('.profile-dropdown')) {
          setIsProfileDropdownOpen(false)
        }
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [isProfileDropdownOpen])

  // Get user's current location, time, and temperature
  useEffect(() => {
    const getLocationData = async () => {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(async (position) => {
          const lat = position.coords.latitude
          const lon = position.coords.longitude

          // Fetching weather data
          const weatherResponse = await fetch(
            `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=6c70008d80c4e8b1f295cdf5b6a9bfde&units=metric`
          )
          const weatherData = await weatherResponse.json()
          setLocation(weatherData.name)
          setTemperature(`${weatherData.main.temp}°C`)

          // Fetching time data based on public IP
          const timeResponse = await fetch("http://worldtimeapi.org/api/ip")
          const timeData = await timeResponse.json()

          // Format the time into a readable format (e.g. "8:23 AM, March 29, 2025")
          const date = new Date(timeData.datetime)
          const formattedTime = date.toLocaleString("en-US", {
            weekday: "short",
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            hour12: true,
          })
          setTime(formattedTime) // Setting formatted time
        })
      } else {
        console.log("Geolocation not supported")
      }
    }

    getLocationData()
  }, [])

  return (
    <header className="grid grid-cols-[auto_1fr_auto_auto] grid-rows-[auto_auto] text-white border-b border-slate-800 bg-slate-900">
      {/* Brand - spans both rows */}
      <div className="row-span-2 bg-slate-800 flex items-center justify-center px-6 border-r border-slate-700">
        <Link href="/" className="text-center">
          {/* Replace Z letter with Lottie animation */}
          <div className="w-12 h-12">
            <Lottie animationData={zLogoAnimation} loop autoplay />
          </div>
          <div className="text-xs text-blue-400 tracking-wide">ZBlog</div>
        </Link>
      </div>

      {/* Welcome + Time/CTA Top Bar */}
      <div className="col-span-3 flex items-center justify-between px-6 h-10 border-b border-slate-800">
        <p className="text-sm text-slate-400 text-center flex-1">
          Welcome to ZBlog — A blog made by me for you
        </p>
        <div className="flex items-center h-full">
          <div className="px-6 h-full flex items-center border-l border-slate-800">
            <span className="text-sm text-slate-400">{time} — {temperature}</span>
          </div>
          <div className="px-6 h-full flex items-center border-l border-r border-slate-800">
            <span className="text-blue-400 font-medium cursor-pointer hover:text-white transition-colors">
              Blog like you never did before
            </span>
          </div>
        </div>
      </div>

      {/* Navigation Row */}
      <div className="col-span-3 flex items-center justify-between px-0 h-14 border-t border-slate-800">
        {/* Navigation Items */}
        <nav className="flex h-full">
        {navItems.map((item, idx) => (
          <Link
            key={item.label}
            href={item.href}
            className={`
              flex items-center px-6 h-full 
              text-sm uppercase tracking-wide 
              text-slate-300 hover:text-white 
              relative group transition-all
              ${idx !== 0 ? 'border-l border-slate-800' : ''}
              ${idx === navItems.length - 1 ? 'border-r border-slate-800' : ''}
            `}
          >
            {item.label}
            <div className="absolute bottom-0 left-0 w-full h-[2px] bg-gradient-to-r from-blue-500 to-teal-500 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-200" />
          </Link>
        ))}
      </nav>

        {/* Search + Auth */}
        {/* Search + Auth */}
  <div className="flex h-full">
    <div className="relative h-full flex items-center px-6 border-l border-slate-800">
      <div className="flex items-center gap-3">
        {isSearchOpen && (
          <motion.input
            initial={{ width: 0, opacity: 0 }}
            animate={{ width: "200px", opacity: 1 }}
            exit={{ width: 0, opacity: 0 }}
            type="text"
            placeholder="Type to search..."
            className="bg-slate-800 text-sm text-slate-200 px-3 py-1.5 rounded-lg border border-slate-700 focus:outline-none focus:border-blue-500/50"
          />
        )}
        <Search 
          className="w-4 h-4 text-slate-400 hover:text-white cursor-pointer" 
          onClick={() => setIsSearchOpen(!isSearchOpen)}
        />
      </div>
    </div>

    {auth.isAuthenticated ? (
  <div className="relative h-full flex items-center px-6 border-l border-r border-slate-800">
    <div
      className="flex items-center gap-2 cursor-pointer"
      onClick={() => setIsProfileDropdownOpen(!isProfileDropdownOpen)}
    >
      <UserCircle className="w-5 h-5 text-slate-200" />
      <span className="text-sm hidden md:inline text-slate-300">
        {auth.user?.profile.email}
      </span>
      <MoreHorizontal className="text-slate-400 w-4 h-4" />
    </div>
    
    {/* Dropdown Menu */}
    {isProfileDropdownOpen && (
      <>
        {/* Overlay */}
        <div 
          className="fixed inset-0 bg-black/20 z-40" 
          onClick={() => setIsProfileDropdownOpen(false)}
        />
        
        {/* Dropdown Content */}
        <div 
          className="absolute right-0 top-[calc(100%+1px)] w-56 bg-slate-800 rounded-lg shadow-lg border border-slate-700 z-50 overflow-hidden"
          onClick={(e) => e.stopPropagation()}
        >
          
          {/* Menu Items */}
          <div className="p-2">
            <button
              onClick={() => {
                auth.removeUser();
                setIsProfileDropdownOpen(false);
              }}
              className="w-full flex items-center gap-2 px-3 py-2 text-sm text-red-400 hover:text-red-300 hover:bg-slate-700/50 rounded-md transition-colors text-left"
            >
              Logout
            </button>
          </div>
        </div>
      </>
    )}
  </div>
    ) : (
      <div className="h-full flex items-center px-6 border-l border-r border-slate-800">
        <div className="flex items-center gap-4">
        <button
  onClick={() => {
    auth.signinRedirect().catch((err) => {
      console.error("Cognito login redirect failed", err);
      alert("Login failed. Check console for details.");
    });
  }}
  className="text-sm text-slate-300 hover:text-white"
>
  Login
</button>

          <div className="w-px h-4 bg-slate-800" />
          <Link
            href="/register"
            className="text-sm text-slate-300 hover:text-white"
          >
            Register
          </Link>
        </div>
      </div>
    )}
  </div>
</div>
    </header>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/PersonalNote.tsx -----
"use client";

import React from "react";

export default function PersonalNote() {
  return (
    <section className="grid gap-8">
      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-500">
        My Journey
      </h2>
      <div className="grid gap-6 text-lg leading-relaxed">
        <p className="text-slate-200">
          zBlog is my full‑stack learning project — built from scratch with no
          generators or shortcuts. I’m continuously evolving my skills from
          GraphQL schemas to OAuth security, all while refining a creative and
          seamless developer experience.
        </p>
        <p className="text-slate-300">
          Every new feature is a step toward mastering modern software engineering,
          and zBlog is the living document of that journey.
        </p>
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/ContactSection.tsx -----
"use client";

import React from "react";
import { GithubIcon, Mail } from "lucide-react";

export default function ContactSection() {
  return (
    <section className="grid gap-8">
      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-500">
        Get in Touch
      </h2>
      <div className="grid gap-6">
        <p className="text-lg text-slate-200">
          I’m always open to collaboration, code reviews, or feedback.
        </p>
        <div className="flex flex-col sm:flex-row gap-4">
          <a
            href="https://github.com/zakariafarih"
            target="_blank"
            rel="noreferrer"
            className="flex items-center gap-3 px-6 py-3 bg-slate-800/50 border border-slate-700 hover:border-blue-500/50 transition-transform transform hover:scale-105"
          >
            <GithubIcon className="w-5 h-5 text-blue-400" />
            <span className="text-slate-200">GitHub</span>
          </a>
          <a
            href="mailto:zakariafarih142@gmail.com"
            className="flex items-center gap-3 px-6 py-3 bg-slate-800/50 border border-slate-700 hover:border-teal-500/50 transition-transform transform hover:scale-105"
          >
            <Mail className="w-5 h-5 text-teal-400" />
            <span className="text-slate-200">Email</span>
          </a>
        </div>
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/TechStackOverview.tsx -----
"use client";

import React from "react";

export default function TechStackOverview() {
  return (
    <section className="grid gap-8">
      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-500">
        Tech Stack &amp; Architecture
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* Backend */}
        <div className="bg-slate-800/50 p-6 shadow-[0_0_8px_#0ff6] border border-slate-700 hover:border-blue-500/50 transition-transform transform hover:scale-105">
          <h3 className="text-xl font-semibold mb-4 text-blue-400">Backend</h3>
          <ul className="space-y-3 text-slate-300">
            {[
              "Spring Boot 3+ microservices",
              "AWS Cognito + OIDC authentication",
              "MySQL on AWS RDS",
              "HTTP/Kafka/event‑driven comms",
              "Dockerized, AWS deployment‑ready",
            ].map((item) => (
              <li key={item} className="flex items-center gap-2">
                <div className="w-1.5 h-1.5 rounded-full bg-blue-500" />
                {item}
              </li>
            ))}
          </ul>
        </div>
        {/* Frontend */}
        <div className="bg-slate-800/50 p-6 shadow-[0_0_8px_#0ff6] border border-slate-700 hover:border-teal-500/50 transition-transform transform hover:scale-105">
          <h3 className="text-xl font-semibold mb-4 text-teal-400">Frontend</h3>
          <ul className="space-y-3 text-slate-300">
            {[
              "Next.js (App Router)",
              "Shadcn/ui &amp; Tailwind CSS",
              "Framer Motion for animations",
              "Rich TinyMCE editor (dark mode)",
              "Modular, component‑based architecture",
            ].map((item) => (
              <li key={item} className="flex items-center gap-2">
                <div className="w-1.5 h-1.5 rounded-full bg-teal-500" />
                {item}
              </li>
            ))}
          </ul>
        </div>
        {/* DevOps */}
        <div className="bg-slate-800/50 p-6 shadow-[0_0_8px_#0ff6] border border-slate-700 hover:border-purple-500/50 transition-transform transform hover:scale-105">
          <h3 className="text-xl font-semibold mb-4 text-purple-400">DevOps</h3>
          <ul className="space-y-3 text-slate-300">
            {[
              "Dockerized services",
              "AWS ECS, API Gateway",
              "CI/CD pipelines",
              "Monitoring &amp; logging",
              "AWS Secrets Manager",
            ].map((item) => (
              <li key={item} className="flex items-center gap-2">
                <div className="w-1.5 h-1.5 rounded-full bg-purple-500" />
                {item}
              </li>
            ))}
          </ul>
        </div>
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/AboutHeader.tsx -----
"use client";

import React from "react";
import { motion } from "framer-motion";

export default function AboutHeader() {
  return (
    <section className="grid gap-8">
      <motion.h1
        className="text-5xl md:text-6xl font-extrabold bg-gradient-to-r from-blue-500 to-teal-500 text-transparent bg-clip-text tracking-wide"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.6, ease: "easeOut" }}
      >
        About zBlog
      </motion.h1>
      <div className="grid gap-6">
        <p className="text-xl text-slate-200 leading-relaxed">
          zBlog is a sleek, developer‑centric blogging platform built with a
          futuristic microservice architecture and cutting‑edge UI design. It’s
          a technical playground for creative developers.
        </p>
        <blockquote className="border-l-4 border-blue-500 pl-6 py-1">
          <p className="text-lg text-slate-300 italic">
            "zBlog is more than a portfolio piece — it’s my technical playground to
            push the limits of what I can create while sharing the journey with the
            community."
          </p>
        </blockquote>
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/About/UpcomingFeatures.tsx -----
"use client";

import React from "react";

export default function UpcomingFeatures() {
  const features = [
    "Comments with nested replies and emoji reactions",
    "Editor preview mode integration",
    "Post scheduling and automated notifications",
    "Advanced file versioning and media explorer",
    "Full public sharing & improved collaboration features",
  ];

  return (
    <section className="grid gap-8">
      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-500">
        What’s Next
      </h2>
      <div className="grid gap-4">
        {features.map((feature, index) => (
          <div
            key={feature}
            className="flex items-center gap-4 p-4 bg-slate-800/50 shadow-[0_0_8px_#0ff6] border border-slate-700 hover:border-cyan-500/50 transition-transform transform hover:scale-105"
          >
            <span className="text-cyan-500 font-mono text-sm">
              0{index + 1}
            </span>
            <p className="text-slate-200">{feature}</p>
          </div>
        ))}
      </div>
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/card.tsx -----
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/select.tsx -----
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/CyberpunkSelect.tsx -----
"use client";

import * as React from "react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { motion } from "framer-motion";
import clsx from "clsx";

interface CyberpunkSelectProps {
  value: string;
  onChange: (value: string) => void;
}

export default function CyberpunkSelect({ value, onChange }: CyberpunkSelectProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: -6 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.25 }}
      className="w-full h-full"
    >
      <Select value={value} onValueChange={onChange}>
        <SelectTrigger
          className={clsx(
            "w-full h-full px-3 py-1.5 text-sm bg-transparent text-slate-200",
            "border-none focus:outline-none focus:ring-0 uppercase tracking-wide",
            "neon-glow"
          )}
        >
          <SelectValue placeholder="Sort..." />
        </SelectTrigger>
        <SelectContent
          className={clsx(
            "bg-slate-900 border border-slate-700 text-slate-300 rounded-none",
            "neon-glow"
          )}
        >
          <SelectItem value="recent">Newest First</SelectItem>
          <SelectItem value="popular">Most Popular</SelectItem>
          <SelectItem value="mostLiked">Most Liked</SelectItem>
        </SelectContent>
      </Select>
    </motion.div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/dropdown-menu.tsx -----
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/ui/button.tsx -----
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/ExplorePostsFilter.tsx -----
"use client"

import React from "react"
import { Search, X } from "lucide-react"
import clsx from "clsx"
import Select from "react-select"

export interface FilterState {
  keyword: string
  tag: string
  dateRange: string
  sort: string
}

interface ExplorePostsFilterProps {
  filters: FilterState
  setFilters: React.Dispatch<React.SetStateAction<FilterState>>
}

const TAG_OPTIONS = [
  "Coding", "TypeScript", "Microservices", "Design", "Cloud",
  "AI", "VS Code", "Python", "Data Science"
].map((tag) => ({ label: tag, value: tag }))

const DATE_OPTIONS = [
  { label: "Today", value: "today" },
  { label: "Last 7 days", value: "7d" },
  { label: "This month", value: "month" },
  { label: "All", value: "all" },
]

export default function ExplorePostsFilter({
  filters,
  setFilters,
}: ExplorePostsFilterProps) {
  const handleChange = (key: keyof FilterState, value: string) => {
    setFilters((prev) => ({ ...prev, [key]: value }))
  }

  return (
    <div className="space-y-4 mb-8 relative z-50">
      {/* Top Filters Row */}
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        {/* Search and Sort */}
        <div className="flex flex-1 gap-3">
          {/* Search Input */}
          <div className="relative w-full max-w-sm">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 w-4 h-4" />
            <input
              type="text"
              value={filters.keyword}
              onChange={(e) => handleChange("keyword", e.target.value)}
              placeholder="Search posts"
              className="w-full bg-slate-800 border border-slate-700 rounded-lg py-2 pl-10 pr-4 text-sm text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          {/* Sort Dropdown */}
          <select
            value={filters.sort}
            onChange={(e) => handleChange("sort", e.target.value)}
            className="bg-slate-800 border border-slate-700 rounded-lg py-2 px-3 text-sm text-white"
          >
            <option value="recent">All time</option>
            <option value="popular">Most Liked</option>
            <option value="comments">Most Commented</option>
          </select>
        </div>

        {/* Date Range + Tags */}
        <div className="flex flex-wrap gap-3 items-center">
          {/* Date Buttons */}
          {DATE_OPTIONS.map((option) => (
            <button
              key={option.value}
              onClick={() => handleChange("dateRange", option.value)}
              className={clsx(
                "px-4 py-1.5 rounded-lg text-sm font-medium border",
                filters.dateRange === option.value
                  ? "bg-blue-600 text-white border-blue-600"
                  : "bg-slate-800 text-slate-300 border-slate-700 hover:bg-slate-700"
              )}
            >
              {option.label}
            </button>
          ))}

          {/* Tag Select */}
          <div className="w-64 relative z-50">
          <Select
            options={TAG_OPTIONS}
            isMulti
            placeholder="Tags"
            classNamePrefix="react-select"
            onChange={(selected) => {
                const value = selected.map((opt) => opt.value).join(",")
                handleChange("tag", value)
            }}
            value={TAG_OPTIONS.filter((opt) => filters.tag.split(",").includes(opt.value))}
            styles={{
                control: (base) => ({
                ...base,
                backgroundColor: "#1e293b",
                borderColor: "#334155",
                color: "white",
                minHeight: "38px",
                }),
                menu: (base) => ({
                ...base,
                backgroundColor: "#1e293b",
                zIndex: 9999,
                }),
                option: (base, state) => ({
                ...base,
                backgroundColor: state.isFocused
                    ? "#2563eb" 
                    : "#1e293b", 
                color: state.isFocused ? "white" : "#e2e8f0", 
                cursor: "pointer",
                }),
                multiValue: (base) => ({ ...base, backgroundColor: "#2563eb" }),
                multiValueLabel: (base) => ({ ...base, color: "white" }),
                input: (base) => ({ ...base, color: "white" }),
            }}
            />
          </div>
        </div>
      </div>

      {/* Tag Pills below search */}
      {filters.tag && filters.tag.split(",").length > 0 && (
        <div className="flex flex-wrap gap-2 pl-1">
          {filters.tag.split(",").map((t) => (
            <div
              key={t}
              className="flex items-center bg-blue-600 text-white px-3 py-1 rounded-full text-sm font-medium"
            >
              {t}
              <button
                onClick={() => {
                  const remaining = filters.tag
                    .split(",")
                    .filter((tag) => tag !== t)
                    .join(",")
                  handleChange("tag", remaining)
                }}
                className="ml-2 hover:text-slate-300"
              >
                <X className="w-4 h-4" />
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/NoPostsHolder.tsx -----
"use client"

import React from "react"
import Lottie from "lottie-react"
import emptyStateAnimation from "@/assets/animations/empty-state.json"

export default function NoPostsHolder() {
  return (
    <div className="flex flex-col items-center justify-center py-16">
      <div className="w-64 h-64">
        <Lottie animationData={emptyStateAnimation} loop={true} />
      </div>
      <p className="mt-4 text-gray-400 text-center">
        Oops! We couldn&apos;t find any posts matching your filters.
      </p>
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/BottomToolbar.tsx -----
"use client";

import React from "react";

interface BottomToolbarProps {
  content: string;
  readingTime: string;
  onDiscard: () => void;
}

const BottomToolbar: React.FC<BottomToolbarProps> = ({
  content,
  readingTime,
  onDiscard,
}) => {
  // Compute word count simply by splitting on whitespace
  const wordCount =
    content.trim() === "" ? 0 : content.trim().split(/\s+/).length;
    
  return (
    <div className="fixed bottom-0 left-0 right-0 bg-slate-800 p-3 flex justify-between items-center text-sm text-slate-400">
      <div>
        <span>Word Count: {wordCount}</span>
        <span className="ml-4">Read Time: {readingTime}</span>
      </div>
      <div>
        <button
          onClick={onDiscard}
          className="hover:underline text-red-400"
        >
          Discard Changes
        </button>
      </div>
    </div>
  );
};

export default BottomToolbar;


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/EditorComponent.tsx -----
"use client";

import React, { useEffect, useRef, useState } from "react";
import dynamic from "next/dynamic";
import hljs from "highlight.js";
import "highlight.js/styles/github-dark.css";
import type { Editor } from 'tinymce';

// 1. Dynamically import the TinyMCE React wrapper (to avoid SSR).
const TinyMCEEditor = dynamic(
  () => import("@tinymce/tinymce-react").then((mod) => mod.Editor),
  { ssr: false }
);

interface EditorComponentProps {
  content: string;
  onContentChange: (val: string) => void;
}

/**
 * Dark-mode TinyMCE with:
 * - Autoresize (no internal scroll)
 * - Codesample plugin for code blocks
 * - Forced paragraphs so you can type after code
 * - No iframes or extra containers
 */
export default function EditorComponent({
  content,
  onContentChange,
}: EditorComponentProps) {
  const [tinyLoaded, setTinyLoaded] = useState(false);
  const previewRef = useRef<HTMLDivElement>(null);

  // 2. Dynamically load TinyMCE on the client (core + plugins).
  useEffect(() => {
    async function loadTinyMCE() {
      if (typeof window !== "undefined") {
        // Core, icons, and theme
        await import("tinymce/tinymce");
        await import("tinymce/icons/default");
        await import("tinymce/themes/silver");

        // Plugins
        await Promise.all([
          import("tinymce/plugins/advlist"),
          import("tinymce/plugins/autolink"),
          import("tinymce/plugins/lists"),
          import("tinymce/plugins/link"),
          import("tinymce/plugins/image"),
          import("tinymce/plugins/charmap"),
          import("tinymce/plugins/preview"),
          import("tinymce/plugins/anchor"),
          import("tinymce/plugins/searchreplace"),
          import("tinymce/plugins/visualblocks"),
          import("tinymce/plugins/fullscreen"),
          import("tinymce/plugins/insertdatetime"),
          import("tinymce/plugins/media"),
          import("tinymce/plugins/table"),
          import("tinymce/plugins/help"),
          import("tinymce/plugins/wordcount"),
          import("tinymce/plugins/codesample"),
          import("tinymce/plugins/autoresize"),
        ]);
      }
      setTinyLoaded(true);
    }
    loadTinyMCE();
  }, []);

  // 3. Use Highlight.js in the preview (optional).
  useEffect(() => {
    if (previewRef.current) {
      previewRef.current.innerHTML = content;
      previewRef.current.querySelectorAll("pre code").forEach((block) => {
        hljs.highlightElement(block as HTMLElement);
      });
    }
  }, [content]);

  if (!tinyLoaded) {
    // Simple loading indicator instead of a blank screen
    return <div className="text-slate-300">Loading editor...</div>;
  }

  return (
    <div className="w-full">
      <TinyMCEEditor
        value={content}
        onEditorChange={onContentChange}
        init={{
          // 4. Serve TinyMCE resources from /tinymce (copy the entire folder to /public/tinymce)
          base_url: "/tinymce",

          // 5. No internal scroll – just grows with content
          plugins:
            "autoresize advlist autolink lists link image charmap preview anchor " +
            "searchreplace visualblocks fullscreen insertdatetime media table " +
            "help wordcount codesample",
          autoresize_min_height: 300,
          autoresize_overflow_padding: 10,

          menubar: false,
          statusbar: false,
          forced_root_block: "p",

          // 6. Provide a convenient toolbar – includes codesample
          toolbar:
            "undo redo | formatselect | " +
            "bold italic backcolor | alignleft aligncenter alignright alignjustify | " +
            "bullist numlist outdent indent | removeformat | codesample | help",

          // 7. Dark theme from self-hosted assets (with forced dark background in content)
          skin: "oxide-dark",
          skin_url: "/tinymce/skins/ui/oxide-dark",
          content_css: "/tinymce/skins/content/dark/content.min.css",
          content_style: `
            body {
              background: #0f172a;
              color: #f1f5f9;
              font-family: sans-serif;
              padding: 1rem;
            }
            a { color: #7dd3fc; }
          `,
          branding: false,

          // 8. The codesample plugin – built-in code insertion, no weird containers
          codesample_languages: [
            { text: "HTML/XML", value: "markup" },
            { text: "JavaScript", value: "javascript" },
            { text: "CSS", value: "css" },
            { text: "PHP", value: "php" },
            { text: "Ruby", value: "ruby" },
            { text: "Python", value: "python" },
            { text: "Java", value: "java" },
            { text: "C", value: "c" },
            { text: "C#", value: "csharp" },
            { text: "C++", value: "cpp" },
          ],

          // 9. Optional: Insert a trailing paragraph if needed
          setup: (editor: Editor) => {
            // On init, ensure there's a blank paragraph at the end
            editor.on("init", () => {
              const raw = editor.getContent({ format: "raw" });
              if (!raw.match(/<p><br\s*\/?><\/p>\s*$/)) {
                editor.setContent(raw + "<p><br/></p>");
              }
            });
            // If user inserts a codesample, ensure there's a paragraph after it to type
            editor.on("ExecCommand", (e) => {
              if (e.command === "mceInsertContent") {
                // Delay a tick so insertion completes
                setTimeout(() => {
                  const updated = editor.getContent({ format: "raw" });
                  if (!updated.match(/<p><br\s*\/?><\/p>\s*$/)) {
                    editor.setContent(updated + "<p><br/></p>");
                  }
                }, 50);
              }
            });
          },
        }}
      />
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/PostMetadataSection.tsx -----
"use client";
import React from "react";
import CoverImageUploader from "./CoverImageUploader";
import TagInput from "../PostDetail/TagInput";

interface PostMetadataSectionProps {
  title: string;
  onTitleChange: (val: string) => void;
  tags: string[];
  onTagsChange: (val: string[]) => void;

  // Renamed props for cover image
  coverImageUrl: string;
  onCoverImageUrlChange: (url: string) => void;
  coverImageKey: string;
  onCoverImageKeyChange: (key: string) => void;
}

export default function PostMetadataSection({
  title,
  onTitleChange,
  tags,
  onTagsChange,
  coverImageUrl,
  onCoverImageUrlChange,
  coverImageKey,
  onCoverImageKeyChange,
}: PostMetadataSectionProps) {
  return (
    <div className="p-4 border-b border-slate-700">
      <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
        <div className="flex-1 space-y-4">
          <input
            type="text"
            placeholder="Post Title"
            value={title}
            onChange={(e) => onTitleChange(e.target.value)}
            className="w-full p-2 text-xl font-bold bg-slate-800 border border-slate-700 rounded focus:outline-none focus:border-teal-500"
          />
          <TagInput tags={tags} onChange={onTagsChange} />
        </div>
        <div className="w-full lg:w-1/3">
          <CoverImageUploader
            coverImageUrl={coverImageUrl}
            onCoverImageUrlChange={onCoverImageUrlChange}
            coverImageKey={coverImageKey}
            onCoverImageKeyChange={onCoverImageKeyChange}
          />
        </div>
      </div>
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/CoverImageUploader.tsx -----
"use client";

import React, { useState, DragEvent } from "react";
import { useUploadFile, UploadResult } from "@/hooks/s3/useUploadFile";
import { useAuth } from "react-oidc-context";
import Image from "next/image";

interface CoverImageUploaderProps {
  coverImageUrl: string;
  onCoverImageUrlChange: (url: string) => void;
  coverImageKey: string;
  onCoverImageKeyChange: (key: string) => void;
}

export default function CoverImageUploader({
  coverImageUrl,
  onCoverImageUrlChange,
  coverImageKey,
  onCoverImageKeyChange,
}: CoverImageUploaderProps) {
  const [uploading, setUploading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const { upload, loading, error } = useUploadFile();
  const auth = useAuth();

  async function handleFileUpload(file: File) {
    setUploading(true);
    setErrorMessage(null);
    try {
      const token = auth.user?.access_token;
      const result: UploadResult | undefined = await upload(file, "cover-images", token);
      if (!result) {
        throw new Error("No response from S3 service");
      }
      onCoverImageUrlChange(result.previewUrl);
      onCoverImageKeyChange(result.fileKey);
    } catch (err: any) {
      console.error("Upload error:", err);
      setErrorMessage(err.message || "Upload failed");
    } finally {
      setUploading(false);
    }
  }

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) handleFileUpload(file);
  };

  const handleDrop = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    const file = event.dataTransfer.files?.[0];
    if (file) handleFileUpload(file);
  };

  const handleDragOver = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
  };

  return (
    <div className="flex flex-col gap-3">
      <div
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        className="relative border-2 border-dashed border-slate-700 rounded-lg p-6 cursor-pointer hover:border-teal-500 transition-colors group"
      >
        <div className="absolute -top-3 left-1/2 -translate-x-1/2">
          <span className="px-3 py-1 bg-slate-800 border border-slate-700 rounded-full text-xs font-medium text-slate-300">
            Cover Image
          </span>
        </div>

        <div className="flex flex-col items-center justify-center min-h-[100px] gap-3">
          {coverImageUrl ? (
            <div className="relative w-full h-40 rounded-md overflow-hidden shadow-lg">
              <Image
                src={coverImageUrl}
                alt="Cover"
                fill
                className="object-cover rounded-md"
                unoptimized 
              />
            </div>
          ) : (
            <div className="flex flex-col items-center gap-2 text-slate-400">
              <svg
                className="w-8 h-8 group-hover:text-teal-500 transition-colors"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                />
              </svg>
              <span className="text-sm">
                Drop an image here or click to upload
              </span>
            </div>
          )}
        </div>

        <input
          type="file"
          accept="image/*"
          onChange={handleFileChange}
          className="absolute inset-0 opacity-0 cursor-pointer"
        />
      </div>

      {(uploading || loading) && (
        <div className="flex items-center justify-center text-sm text-teal-300">
          <div className="animate-spin mr-2 h-4 w-4 border-2 border-teal-500 rounded-full border-t-transparent"></div>
          Uploading...
        </div>
      )}

      {(errorMessage || error) && (
        <div className="text-sm text-red-400 text-center">
          {errorMessage || error}
        </div>
      )}
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCreation/TopUtilityBar.tsx -----
"use client";

import React from "react";

/**
 * TopUtilityBar
 * A sticky header showing:
 * - A link "Back to Dashboard"
 * - An auto-save indicator
 * - Preview button
 * - Publish button
 */
interface TopUtilityBarProps {
  autoSaveStatus: string;
  onPreview: () => void;
  onPublish: () => void;
}

const TopUtilityBar: React.FC<TopUtilityBarProps> = ({
  autoSaveStatus,
  onPreview,
  onPublish
}) => {
  return (
    <div className="sticky top-0 z-50 flex items-center justify-between p-3 bg-slate-700 border-slate-900 shadow-md">
      <div className="flex items-center gap-4">
        <span className="text-sm text-slate-400">{autoSaveStatus}</span>
      </div>
      <div className="flex items-center gap-4">
        <button
          onClick={onPreview}
          className="px-3 py-1 bg-slate-700 rounded hover:bg-slate-600 transition"
        >
          Preview Post
        </button>
        <button
          onClick={onPublish}
          className="px-4 py-1 bg-teal-500 rounded hover:bg-teal-400 transition font-bold"
        >
          Publish
        </button>
      </div>
    </div>
  );
};

export default TopUtilityBar;


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/AnimatedHeaderPost.tsx -----
"use client"

import Lottie from "lottie-react"
import explorerAnimation from "@/assets/animations/explorer-walking.json"
import { motion, useAnimationControls } from "framer-motion"
import { useLayoutEffect, useRef, useState } from "react"

export default function AnimatedHeaderPost() {
  const [showText, setShowText] = useState(false)
  const controls = useAnimationControls()
  const containerRef = useRef<HTMLDivElement>(null)

  useLayoutEffect(() => {
    let isMounted = true
    if (!containerRef.current) return

    const containerWidth = containerRef.current.offsetWidth
    const detectiveWidth = 64 
    const travelDistance = (containerWidth - detectiveWidth - 30) + containerWidth * 0.25;

    const runAnimation = async () => {
      if (!isMounted) return
      await controls.start({ x: travelDistance, scaleX: 1, transition: { duration: 3.2 } })
      await controls.start({ scaleX: -1, transition: { duration: 0.4 } })
      await controls.start({ x: 0, transition: { duration: 2.8 } })
      await controls.start({ scaleX: 1, transition: { duration: 0.4 } })

      if (!isMounted) return
      setShowText(true)
    }

    runAnimation()
    return () => { isMounted = false }
  }, [controls])

  return (
    <div
      ref={containerRef}
      className="relative bg-slate-900 border border-slate-700 mb-4 px-6 py-2 shadow-inner neon-glow-box"
    >
      {/* Detective Animation */}
      <motion.div
        className="absolute top-1/2 -translate-y-1/2 w-16 h-16 z-10 scale-[0.8]" // ⬅️ Smaller and tighter
        initial={{ x: 0, scaleX: 1 }}
        animate={controls}
      >
        <Lottie animationData={explorerAnimation} loop />
      </motion.div>

      {/* Text Content */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: showText ? 1 : 0 }}
        transition={{ duration: 0.6, delay: 0.2 }}
        className="relative z-0 flex flex-col md:flex-row md:items-end md:justify-between w-full pl-20"
      >
        <h1 className="text-xl md:text-2xl font-bold uppercase tracking-wider text-cyan-300">
          Explore Posts
        </h1>
        <p className="text-slate-400 text-xs md:text-sm md:text-right max-w-md mt-1 md:mt-0">
          Use filters and keywords to find the freshest, most relevant content.
        </p>
      </motion.div>

      <div className="absolute bottom-0 left-0 w-full h-px bg-slate-700" />
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/TagInput.tsx -----
"use client";

import React, { useState, KeyboardEvent } from "react";

interface TagInputProps {
  tags: string[];
  onChange: (tags: string[]) => void;
}

/**
 * Renders a row of chips for each tag.
 * On Enter or Comma, we add a new tag.
 * On chip 'x' click, remove that tag.
 */
export default function TagInput({ tags, onChange }: TagInputProps) {
  const [inputValue, setInputValue] = useState("");

  function handleKeyDown(e: KeyboardEvent<HTMLInputElement>) {
    if (e.key === "Enter" || e.key === ",") {
      e.preventDefault();
      const newTag = inputValue.trim();
      if (newTag && !tags.includes(newTag)) {
        onChange([...tags, newTag]);
      }
      setInputValue("");
    }
  }

  function removeTag(tag: string) {
    onChange(tags.filter((t) => t !== tag));
  }

  return (
    <div className="flex flex-col gap-2">
      {/* Tag Chips */}
      <div className="flex flex-wrap gap-2">
        {tags.map((tag) => (
          <div
            key={tag}
            className="flex items-center bg-teal-600 text-white px-2 py-1 rounded-full text-sm"
          >
            {tag}
            <button
              onClick={() => removeTag(tag)}
              className="ml-2 text-white hover:text-gray-200"
            >
              &times;
            </button>
          </div>
        ))}
      </div>

      {/* Input for new tag */}
      <input
        type="text"
        className="w-full p-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:border-teal-500"
        placeholder="Add tags, then press Enter..."
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyDown={handleKeyDown}
      />
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/PostMetadata.tsx -----
"use client"

import React from "react"
import Image from "next/image"
import { cn } from "@/lib/utils"
import { formatDistanceToNow } from "date-fns"

interface PostMetadataProps {
  author: {
    name: string
    avatarUrl: string
  }
  publishedAt: Date
  tags: string[];
  className?: string
}

export default function PostMetadata({
  author,
  publishedAt,
  tags,
  className,
}: PostMetadataProps) {
  return (
    <div className={cn("flex items-center gap-3 text-slate-400 text-sm", className)}>
      {/* Avatar */}
      <div className="w-8 h-8 rounded-full overflow-hidden">
        <Image
          src={author.avatarUrl}
          alt={author.name}
          width={32}
          height={32}
          className="object-cover"
        />
      </div>

      {/* Name, Time, Tag */}
      <div className="flex flex-wrap items-center gap-1.5">
        <span className="text-white font-medium">{author.name}</span>
        <span>•</span>
        <span>{formatDistanceToNow(publishedAt, { addSuffix: true })}</span>
        <span>•</span>
        <div className="flex gap-2 flex-wrap mt-1">
        {Array.isArray(tags) &&
          tags.map((tag) => (
            <span
              key={tag}
              className="bg-blue-600 text-white px-2 py-0.5 rounded-full text-xs font-medium"
            >
              {tag}
            </span>
        ))}
        </div>
      </div>
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/PostHeader.tsx -----
"use client";

import React from "react";
import Image from "next/image";
import PostMetadata from "./PostMetadata";

interface PostHeaderProps {
  title: string;
  coverImageUrl: string;
  author: {
    name: string;
    avatarUrl: string;
  };
  publishedAt: Date;
  tags: string[];
}

export default function PostHeader({
  title,
  coverImageUrl,
  author,
  publishedAt,
  tags,
}: PostHeaderProps) {
  // Check if the coverImageUrl is valid (e.g. non-empty and begins with "http" or "/")
  const isValidUrl = coverImageUrl && (coverImageUrl.startsWith("http") || coverImageUrl.startsWith("/"));

  // If not valid, use a fallback default image.
  const resolvedCoverImageUrl = isValidUrl ? coverImageUrl : "/default-cover.jpg";

  return (
    <div className="mb-6">
      {/* Banner image */}
      <div className="w-full h-48 md:h-56 lg:h-64 overflow-hidden rounded-md mb-6">
        <Image
          src={resolvedCoverImageUrl}
          alt="Post cover"
          width={1200}
          height={400}
          className="w-full h-full object-cover object-center"
          unoptimized
        />
      </div>

      {/* Title */}
      <h1 className="text-3xl md:text-4xl font-bold text-white mb-4">
        {title}
      </h1>

      {/* Metadata */}
      <PostMetadata author={author} publishedAt={publishedAt} tags={tags} />
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/CommentList.tsx -----
"use client";

import React from "react";
import { useComments } from "@/hooks/comment/useComments";
import CommentItem from "./CommentItem";
import LoadMoreButton from "./LoadMoreButton";

interface CommentListProps {
  postId: string;
}

export default function CommentList({ postId }: CommentListProps) {
  const { comments, hasNextPage, fetchNextPage, isLoading } = useComments(postId);

  if (isLoading) {
    return <div>Loading comments...</div>;
  }

  return (
    <div className="space-y-4">
      {comments.map((comment) => (
        <CommentItem key={comment.id} comment={comment} />
      ))}
      {hasNextPage && (
        <LoadMoreButton onClick={fetchNextPage} label="Load More Comments" />
      )}
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/CommentForm.tsx -----
"use client";

import React, { useState, useRef, useEffect } from "react";
import { useCreateComment } from "@/hooks/comment/useCreateComment";
import { CommentResponseDTO } from "@/services/commentService";

interface CommentFormProps {
  postId: string;
  parentId?: string;
  onSuccess: (newComment: CommentResponseDTO) => void;
}

export default function CommentForm({ postId, parentId, onSuccess }: CommentFormProps) {
  const [content, setContent] = useState("");
  const { create, loading, error } = useCreateComment();
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  const handleSubmit = async () => {
    if (!content.trim()) return;
    const req = { postId, parentId, content };
    const newComment = await create(req);
    if (newComment) {
      onSuccess(newComment);
      setContent("");
    }
  };

  return (
    <div className="flex items-center gap-3 mt-4">
      <input
        ref={inputRef}
        type="text"
        placeholder="Write a comment..."
        value={content}
        onChange={(e) => setContent(e.target.value)}
        className="flex-1 bg-slate-800 border border-slate-700 rounded px-3 py-2 text-white focus:outline-none"
      />
      <button onClick={handleSubmit} disabled={loading} className="text-sm text-blue-500 font-medium hover:underline">
        Post
      </button>
      {error && <span className="text-red-500 text-xs">{error}</span>}
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/ReplyButton.tsx -----
"use client";

import React from "react";

interface ReplyButtonProps {
  commentId: string;
  onReply?: (commentId: string) => void;
}

export default function ReplyButton({ commentId, onReply }: ReplyButtonProps) {
  const handleReply = () => {
    if (onReply) {
      onReply(commentId);
    }
  };

  return (
    <button onClick={handleReply} className="hover:underline text-sm text-blue-400">
      Reply
    </button>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/ReactionButtons.tsx -----
"use client";

import React from "react";
import { ThumbsUp, Smile, Frown, Lightbulb } from "lucide-react";
import { CommentResponseDTO } from "@/services/commentService";
import { useToggleCommentReaction } from "@/hooks/comment/useToggleCommentReaction";
import { useAuth } from "react-oidc-context";

interface ReactionButtonsProps {
  comment: CommentResponseDTO;
}

export default function ReactionButtons({ comment }: ReactionButtonsProps) {
  const auth = useAuth();
  const { toggle } = useToggleCommentReaction();

  const handleReaction = async (reactionType: string) => {
    if (!auth.user) return;
    await toggle(comment.id, reactionType, auth.user.access_token);
    // Optionally, trigger a refresh or update local state here.
  };

  return (
    <div className="flex items-center gap-4">
      <button onClick={() => handleReaction("like")} className="flex items-center gap-1 text-sm hover:underline">
        <ThumbsUp size={16} /> {comment.likeCount}
      </button>
      <button onClick={() => handleReaction("laugh")} className="flex items-center gap-1 text-sm hover:underline">
        <Smile size={16} /> {comment.laughCount}
      </button>
      <button onClick={() => handleReaction("sad")} className="flex items-center gap-1 text-sm hover:underline">
        <Frown size={16} /> {comment.sadCount}
      </button>
      <button onClick={() => handleReaction("insightful")} className="flex items-center gap-1 text-sm hover:underline">
        <Lightbulb size={16} /> {comment.insightfulCount}
      </button>
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/CommentSection.tsx -----
"use client";

import React from "react";
import CommentList from "./CommentList";
import CommentForm from "./CommentForm";

interface CommentSectionProps {
  postId: string;
}

export default function CommentSection({ postId }: CommentSectionProps) {
  return (
    <section id="comment-section" className="mt-10">
      <h2 className="text-xl font-semibold mb-1">Comments</h2>
      <CommentForm postId={postId} onSuccess={(newComment) => console.log(newComment)} />
      <CommentList postId={postId} />
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/PostReactionPanel.tsx -----
"use client";

import React from "react";
import { ThumbsUp, MessageSquare, Share2, Bookmark } from "lucide-react";
import { motion } from "framer-motion";
import clsx from "clsx";

interface ReactionPanelProps {
  liked?: boolean;
  bookmarked?: boolean;
  onLike?: () => void;
  onCommentClick?: () => void;
  onShare?: () => void;
  onBookmark?: () => void;
}

const iconButtonStyle = (active = false) =>
  clsx(
    "w-10 h-10 flex items-center justify-center rounded-md transition-colors border border-slate-700 hover:bg-slate-700",
    active ? "bg-blue-600 text-white" : "bg-slate-800 text-slate-300"
  );

export default function PostReactionPanel({
  liked,
  bookmarked,
  onLike,
  onCommentClick,
  onShare,
  onBookmark,
}: ReactionPanelProps) {
  return (
    <motion.div
      initial={{ opacity: 0, x: 30 }}
      animate={{ opacity: 1, x: 0 }}
      transition={{ duration: 0.4, delay: 0.2 }}
      className="hidden lg:flex flex-col gap-4 sticky top-28 ml-6"
    >
      <button onClick={onLike} className={iconButtonStyle(!!liked)}>
        <ThumbsUp size={18} />
      </button>
      <button onClick={onCommentClick} className={iconButtonStyle()}>
        <MessageSquare size={18} />
      </button>
      <button onClick={onShare} className={iconButtonStyle()}>
        <Share2 size={18} />
      </button>
      <button onClick={onBookmark} className={iconButtonStyle(!!bookmarked)}>
        <Bookmark size={18} />
      </button>
    </motion.div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/Comment.tsx -----
"use client"

import React from "react"
import Image from "next/image"
import { MoreVertical } from "lucide-react"

interface CommentProps {
  author: {
    name: string
    avatarUrl: string
  }
  timestamp: string
  content: string
  likes: number
}

export default function Comment({ author, timestamp, content, likes }: CommentProps) {
  return (
    <div className="flex items-start gap-4 py-4 border-b border-slate-700">
      {/* Avatar */}
      <div className="w-10 h-10 flex-shrink-0 rounded-full overflow-hidden">
        <Image
          src={author.avatarUrl}
          alt={author.name}
          width={40}
          height={40}
          className="rounded-full object-cover"
        />
      </div>

      {/* Main content */}
      <div className="flex-1">
        {/* Top Row */}
        <div className="flex justify-between items-center mb-1">
          <div className="flex items-center gap-2 text-sm text-slate-300">
            <span className="font-semibold text-white">{author.name}</span>
            <span className="text-slate-500">•</span>
            <span>{timestamp}</span>
          </div>
          <MoreVertical className="w-4 h-4 text-slate-500 cursor-pointer hover:text-slate-300" />
        </div>

        {/* Comment Content */}
        <p className="text-slate-100 text-sm mb-2">{content}</p>

        {/* Bottom Row */}
        <div className="flex items-center justify-between text-sm text-slate-400">
          <button className="hover:underline text-sm">Reply</button>
          <span>{likes}</span>
        </div>
      </div>
    </div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/LoadMoreButton.tsx -----
"use client";

import React from "react";

interface LoadMoreButtonProps {
  onClick: () => void;
  label?: string;
}

export default function LoadMoreButton({ onClick, label = "Load More" }: LoadMoreButtonProps) {
  return (
    <button
      onClick={onClick}
      className="mt-4 px-4 py-2 bg-slate-700 text-white rounded hover:bg-slate-600 transition-colors"
    >
      {label}
    </button>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/PostDetail.tsx -----
"use client";

import React from "react";
import PostHeader from "./PostHeader";
import PostReactionPanel from "./PostReactionPanel";
import CommentSection from "./CommentSection";

interface PostDetailProps {
  post: {
    id: string;
    title: string;
    coverImageUrl: string;
    author: { name: string; avatarUrl: string };
    publishedAt: Date;
    tags: string[];
    content: string;
  };
  onLike?: () => void;
  onBookmark?: () => void;
  onShare?: () => void;
  onCommentClick?: () => void;
}

export default function PostDetail({
  post,
  onLike,
  onBookmark,
  onShare,
  onCommentClick,
}: PostDetailProps) {
  return (
    <main className="bg-slate-900 text-white min-h-screen pt-6 pb-20">
      <section className="max-w-6xl mx-auto px-4 md:px-8 flex gap-10">
        <div className="hidden lg:block">
          <PostReactionPanel
            onLike={onLike}
            onBookmark={onBookmark}
            onShare={onShare}
            onCommentClick={onCommentClick}
          />
        </div>
        <div className="flex-1">
          <PostHeader
            title={post.title}
            coverImageUrl={post.coverImageUrl}
            author={post.author}
            publishedAt={post.publishedAt}
            tags={post.tags}
          />
          <article
            className="text-slate-300 leading-relaxed space-y-6"
            dangerouslySetInnerHTML={{ __html: post.content }}
          />
          <CommentSection postId={post.id!} />
        </div>
      </section>
    </main>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/BookmarkButton.tsx -----
"use client";

import React, { useState } from "react";
import { Bookmark } from "lucide-react";
import { createBookmark, removeBookmark } from "@/services/userService";
import { useAuth } from "react-oidc-context";

interface BookmarkButtonProps {
  postId: string;
  initialBookmarked?: boolean;
}

export default function BookmarkButton({ postId, initialBookmarked = false }: BookmarkButtonProps) {
  const [bookmarked, setBookmarked] = useState(initialBookmarked);
  const auth = useAuth();

  const handleToggle = async () => {
    const token = auth.user?.access_token;
    if (!token) return;
    if (bookmarked) {
      await removeBookmark(postId, token);
      setBookmarked(false);
    } else {
      await createBookmark(postId, token);
      setBookmarked(true);
    }
  };

  return (
    <button onClick={handleToggle} className="p-2 rounded hover:bg-slate-700 transition">
      <Bookmark className={`w-6 h-6 ${bookmarked ? "text-blue-500" : "text-slate-400"}`} />
    </button>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostDetail/CommentItem.tsx -----
"use client";

import React from "react";
import Image from "next/image";
import { MoreVertical } from "lucide-react";
import ReactionButtons from "./ReactionButtons";
import ReplyButton from "./ReplyButton";
import { CommentResponseDTO } from "@/services/commentService";

interface CommentItemProps {
  comment: CommentResponseDTO;
  onReply?: (commentId: string) => void;
}

export default function CommentItem({ comment, onReply }: CommentItemProps) {
  return (
    <div className="flex items-start gap-4 py-4 border-b border-slate-700">
      <div className="w-10 h-10 flex-shrink-0 rounded-full overflow-hidden">
        <Image src="/avatars/default.png" alt="Author" width={40} height={40} className="rounded-full" />
      </div>
      <div className="flex-1">
        <div className="flex justify-between items-center mb-1">
          <div className="flex items-center gap-2 text-sm text-slate-300">
            <span className="font-semibold text-white">{comment.authorId}</span>
            <span className="text-slate-500">•</span>
            <span>{new Date(comment.createdAt).toLocaleString()}</span>
          </div>
          <MoreVertical className="w-4 h-4 text-slate-500 cursor-pointer hover:text-slate-300" />
        </div>
        <p className="text-slate-100 text-sm mb-2">{comment.content}</p>
        <div className="flex items-center justify-between text-sm text-slate-400">
          <ReplyButton commentId={comment.id} onReply={onReply} />
          <ReactionButtons comment={comment} />
        </div>
        {comment.replies && comment.replies.length > 0 && (
          <div className="ml-8 mt-4">
            {comment.replies.map((reply) => (
              <CommentItem key={reply.id} comment={reply} onReply={onReply} />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/HeaderRecentPosts.tsx -----
"use client"

import React from "react"
import Lottie from "lottie-react"
import newspaperAnimation from "@/assets/animations/recent-newspaper.json"
import { motion } from "framer-motion"

export default function HeaderRecentPosts() {
  return (
    <motion.div
      initial={{ opacity: 0, y: 12 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="mb-4 border border-slate-700 bg-slate-900 px-4 py-2 md:px-6 md:py-2.5 shadow-inner neon-glow-box"
    >
      <div className="flex flex-col md:flex-row md:items-end md:justify-between gap-3">
        {/* Icon + Title */}
        <div className="flex items-center gap-3">
          <motion.div
            whileHover={{ scale: 1.1 }}
            transition={{ type: "spring", stiffness: 300 }}
            className="w-10 h-10 md:w-12 md:h-12"
          >
            <Lottie animationData={newspaperAnimation} loop autoplay />
          </motion.div>
          <h1 className="text-xl md:text-2xl font-bold uppercase tracking-wide text-cyan-300">
            Recent Posts
          </h1>
        </div>

        {/* Description */}
        <p className="text-slate-400 text-xs md:text-sm md:text-right max-w-md leading-snug mt-1 md:mt-0">
          Catch up on what the community is talking about!
        </p>
      </div>

      <div className="absolute bottom-0 left-0 w-full h-px bg-slate-700" />
    </motion.div>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/PostCard.tsx -----
"use client";

import React, { useEffect, useState } from "react";
import { motion } from "framer-motion";
import { ThumbsUp, MessageCircle } from "lucide-react";
import Image from "next/image";
import DOMPurify from "dompurify";

export interface PostCardProps {
  id: string;
  title: string;
  description: string;
  author: string;
  timestamp: string;
  tags?: string[];
  imageUrl?: string;
  reactionCount?: number;
  commentCount?: number;
  onClick?: (postId: string) => void;
}

export default function PostCard({
  id,
  title,
  description,
  author,
  timestamp,
  tags = [],
  imageUrl,
  reactionCount = 0,
  commentCount = 0,
  onClick,
}: PostCardProps) {
  const [safeDescription, setSafeDescription] = useState("");

  useEffect(() => {
    if (typeof window !== "undefined") {
      setSafeDescription(DOMPurify.sanitize(description));
    }
  }, [description]);

  return (
    <motion.div
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={() => onClick?.(id)}
      className="relative h-64 w-full rounded-xl overflow-hidden shadow-md bg-slate-800 cursor-pointer"
    >
      {imageUrl && (
        <Image
          src={imageUrl}
          alt={title}
          fill
          className="object-cover blur-sm opacity-60"
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          unoptimized
        />
      )}

      <div className="relative z-10 flex flex-col justify-end h-full p-4">
        <div className="flex flex-wrap gap-2 mb-2">
          {tags.map((tag) => (
            <span
              key={tag}
              className="bg-blue-600 text-white text-xs font-medium px-2 py-1 rounded"
            >
              {tag}
            </span>
          ))}
        </div>

        <h3 className="text-white text-lg font-semibold line-clamp-1">{title}</h3>
        <p className="text-gray-300 text-sm line-clamp-2 mt-1">
          {/* Only render if it's sanitized (i.e. on the client) */}
          {safeDescription && (
            <span dangerouslySetInnerHTML={{ __html: safeDescription }} />
          )}
        </p>

        <div className="flex justify-between items-center mt-3 text-xs text-gray-400 bg-slate-950 -mx-4 -mb-4 p-3 border-t border-slate-800">
          <span>
            By {author} · {timestamp}
          </span>
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-1">
              <ThumbsUp className="w-4 h-4 text-gray-400" />
              <span>{reactionCount}</span>
            </div>
            <div className="flex items-center gap-1">
              <MessageCircle className="w-4 h-4 text-gray-400" />
              <span>{commentCount}</span>
            </div>
          </div>
        </div>
      </div>
    </motion.div>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/RecentPosts.tsx -----
'use client'

import React, { useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { motion } from 'framer-motion'
import PostCard, { PostCardProps } from './PostCard'
import HeaderRecentPosts from './HeaderRecentPosts'
import { getAuthorName, hasAuthor } from '@/services/authorCache'
import { useAuth } from 'react-oidc-context'

interface RawPost extends PostCardProps {
  authorId?: string
}

interface RecentPostsProps {
  posts: RawPost[]
  onLoadMore?: () => void
  hasMore?: boolean
}

const containerVariants = {
  hidden: {},
  visible: {
    transition: {
      staggerChildren: 0.1,
    },
  },
}

const cardVariants = {
  hidden: { opacity: 0, y: 30 },
  visible: { opacity: 1, y: 0 },
}

export default function RecentPosts({
  posts,
  onLoadMore,
  hasMore = false,
}: RecentPostsProps) {
  const router = useRouter()
  const auth = useAuth()
  const [resolvedPosts, setResolvedPosts] = useState<PostCardProps[]>([])

  useEffect(() => {
    const resolveAuthors = async () => {
      const token = auth.user?.access_token

      const updatedPosts = await Promise.all(
        posts.map(async (post) => {
          if (post.authorId) {
            const author = await getAuthorName(post.authorId, token)
            return { ...post, author }
          }
          return post
        })
      )

      setResolvedPosts(updatedPosts)
    }

    resolveAuthors()
  }, [posts, auth.user])

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <HeaderRecentPosts />

      <motion.div
        className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {resolvedPosts.map((post) => (
          <motion.div key={post.id} variants={cardVariants}>
            <PostCard
              {...post}
              onClick={(postId) => router.push(`/posts/${postId}`)}
            />
          </motion.div>
        ))}
      </motion.div>

      {hasMore && (
        <div className="flex justify-center mt-10 border-t border-slate-700 pt-10">
          <motion.button
            onClick={onLoadMore}
            whileHover={{ scale: 1.03 }}
            whileTap={{ scale: 0.97 }}
            className="bg-slate-700 hover:bg-slate-600 text-white rounded-xl py-2 px-6 font-medium transition"
          >
            Load More
          </motion.button>
        </div>
      )}
    </section>
  )
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/ExplorePostsContent.tsx -----
'use client';

import React, { useEffect, useState } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import dynamic from 'next/dynamic';
import NoPostsHolder from '@/components/posts/NoPostsHolder';
import PostCard, { PostCardProps } from '@/components/posts/PostCard';
import AnimatedHeaderPost from '@/components/posts/AnimatedHeaderPost';
import { useAuth } from 'react-oidc-context';
import { explorePosts, PostDTO } from '@/services/postService';
import { FilterState } from '@/types/filters';
import Fallback from '@/components/Fallback/Fallback';
import { getAuthorName, hasAuthor } from '@/services/authorCache';

const ExplorePostsFilter = dynamic(
  () => import('@/components/posts/ExplorePostsFilter.client'),
  { ssr: false }
);

export default function ExplorePostsContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const initialTag = searchParams.get('tag') || '';
  const auth = useAuth();

  const [filters, setFilters] = useState<FilterState>({
    keyword: '',
    tag: '',
    sort: 'recent',
    dateRange: 'all',
  });

  const [posts, setPosts] = useState<PostCardProps[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // Set filters on mount if tag param is present
  useEffect(() => {
    if (initialTag) {
      setFilters((prev) => ({
        ...prev,
        tag: initialTag,
      }));

      // Clean URL after syncing
      const params = new URLSearchParams(searchParams.toString());
      params.delete('tag');
      router.replace(`/posts?${params.toString()}`, { scroll: false });
    }
  }, [initialTag]);

  // Fetch posts when filters or auth is ready
  useEffect(() => {
    const fetchPosts = async () => {
      setLoading(true);
      const token = auth.user?.access_token;
      const page = 0;
      const size = 30;
      const tagList = filters.tag ? [filters.tag] : [];
  
      try {
        const dataPage = await explorePosts(
          filters.keyword,
          tagList,
          filters.sort,
          page,
          size,
          token
        );
  
        const postsWithAuthors = await Promise.all(
          dataPage.content.map(async (post) => {
            let author = 'Unknown Author';
        
            if (post.authorId) {
              if (hasAuthor(post.authorId)) {
                author = await getAuthorName(post.authorId);
              } else {
                author = await getAuthorName(post.authorId, token);
              }
            }
        
            return {
              id: post.id!,
              title: post.title,
              description: post.content,
              author,
              timestamp: post.createdAt
                ? new Date(post.createdAt).toLocaleDateString()
                : '',
              tags: post.tags || [],
              imageUrl: post.bannerImageUrl || '/default-cover.jpg',
              reactionCount: (post.likeCount || 0) + (post.heartCount || 0),
              commentCount: 0,
              onClick: () => router.push(`/posts/${post.id}`),
            };
          })
        );        
  
        setPosts(postsWithAuthors);
      } catch (e) {
        console.error('Failed to fetch posts:', e);
      } finally {
        setLoading(false);
      }
    };
  
    if (auth.user) {
      fetchPosts();
    }
  }, [filters, auth.user]);  

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <AnimatedHeaderPost />
      <ExplorePostsFilter filters={filters} setFilters={setFilters} />
      {loading ? (
        <Fallback message="Loading Explore Posts..." />
      ) : posts.length > 0 ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mt-6">
          {posts.map((post) => (
            <PostCard
              key={post.id}
              {...post}
              onClick={() => router.push(`/posts/${post.id}`)}
            />
          ))}
        </div>
      ) : (
        <div className="mt-10">
          <NoPostsHolder />
        </div>
      )}
    </section>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/ExplorePostsFilter.client.tsx -----
"use client";

import React, { useState } from "react";
import Lottie from "lottie-react";
import searchLottie from "@/assets/animations/searchLottie.json";
import CyberpunkSelect from "@/components/ui/CyberpunkSelect";
import { FilterState } from "@/types/filters";

interface ExplorePostsFilterProps {
  filters: FilterState;
  setFilters: React.Dispatch<React.SetStateAction<FilterState>>;
}

const ExplorePostsFilter: React.FC<ExplorePostsFilterProps> = ({ filters, setFilters }) => {
  const [localFilters, setLocalFilters] = useState(filters);

  const updateLocalFilter = (field: keyof FilterState, value: string) => {
    setLocalFilters((prev) => ({ ...prev, [field]: value }));
  };

  const handleSearch = () => {
    setFilters(localFilters);
  };

  return (
    <div className="mb-6 px-4 md:px-0 font-mono">
      <div className="grid md:grid-cols-[1fr_1fr_1fr_auto] border border-slate-700 divide-x divide-slate-700 overflow-hidden shadow-md">
        {/* Keyword */}
        <div className="bg-slate-900 p-2 flex items-center">
          <input
            type="text"
            placeholder="Search posts..."
            value={localFilters.keyword}
            onChange={(e) => updateLocalFilter("keyword", e.target.value)}
            className="w-full bg-transparent text-slate-200 text-sm border-none px-1 py-1.5 placeholder-slate-500 focus:outline-none focus:ring-0"
          />
        </div>

        {/* Tag */}
        <div className="bg-slate-900 p-2 flex items-center">
          <input
            type="text"
            placeholder="Filter by tag..."
            value={localFilters.tag}
            onChange={(e) => updateLocalFilter("tag", e.target.value)}
            className="w-full bg-transparent text-slate-200 text-sm border-none px-1 py-1.5 placeholder-slate-500 focus:outline-none focus:ring-0"
          />
        </div>

        {/* Sort */}
        <div className="bg-slate-900 p-2 flex items-center">
          <CyberpunkSelect
            value={localFilters.sort}
            onChange={(val) => updateLocalFilter("sort", val)}
          />
        </div>

        {/* Search Button */}
        <div className="bg-slate-900 p-2 flex items-center justify-center hover:bg-slate-800 transition-colors">
          <button
            onClick={handleSearch}
            className="w-full h-full flex items-center justify-center hover:scale-105 transition-transform duration-150"
          >
            <Lottie animationData={searchLottie} loop style={{ width: 36, height: 36 }} />
          </button>
        </div>
      </div>
    </div>
  );
};

export default ExplorePostsFilter;


----- /home/zakaria/zBlog/zblog-frontend/src/components/posts/BookmarkButton.tsx -----


----- /home/zakaria/zBlog/zblog-frontend/src/app/posts/page.tsx -----
"use client";

import React, { Suspense } from "react";
import ExplorePostsContent from "@/components/posts/ExplorePostsContent";
import Fallback from "@/components/Fallback/Fallback";
import ErrorBoundary from "@/components/Fallback/ErrorBoundary";

export default function ExplorePostsPage() {
  return (
    <main className="bg-slate-900 text-white min-h-screen pt-4 pb-16 overflow-hidden">
      <ErrorBoundary fallback={<Fallback message="Something went wrong loading posts." />}>
        <Suspense fallback={<Fallback message="Loading Explore Feed..." />}>
          <ExplorePostsContent />
        </Suspense>
      </ErrorBoundary>
    </main>
  );
}


----- /home/zakaria/zBlog/zblog-frontend/src/app/posts/mockPosts.ts -----
import type { PostCardProps } from "@/components/posts/PostCard";

export const mockPosts: PostCardProps[] = [
  {
    id: "1",
    title: "Mastering TypeScript",
    description: "Discover the power of static typing in JavaScript and how it can improve your productivity.",
    author: "Zakaria",
    timestamp: "2 hours ago",
    tags: ["Coding", "TypeScript"],
    imageUrl: "https://picsum.photos/600/400?random=1",
    reactionCount: 24,
    commentCount: 5,
  },
  {
    id: "2",
    title: "Exploring Microservices Architecture",
    description: "Learn how a microservices architecture can help you build scalable applications.",
    author: "Alice",
    timestamp: "3 hours ago",
    tags: ["Microservices", "Architecture"],
    imageUrl: "https://picsum.photos/600/400?random=2",
    reactionCount: 35,
    commentCount: 12,
  },
  {
    id: "3",
    title: "UI/UX Best Practices",
    description: "Designing interfaces that are not only visually appealing but also provide great user experience.",
    author: "Bob",
    timestamp: "5 hours ago",
    tags: ["Design", "UI/UX"],
    imageUrl: "https://picsum.photos/600/400?random=3",
    reactionCount: 10,
    commentCount: 8,
  },
  {
    id: "4",
    title: "Understanding Cloud-Native Development",
    description: "An in-depth look into building applications using cloud-native technologies and microservices.",
    author: "Clara",
    timestamp: "1 day ago",
    tags: ["Cloud", "Microservices"],
    imageUrl: "https://picsum.photos/600/400?random=4",
    reactionCount: 18,
    commentCount: 3,
  },
  {
    id: "5",
    title: "The Future of AI in Software Development",
    description: "How artificial intelligence is reshaping coding, testing, and deployment workflows.",
    author: "Derek",
    timestamp: "2 days ago",
    tags: ["AI", "Software Development"],
    imageUrl: "https://picsum.photos/600/400?random=5",
    reactionCount: 44,
    commentCount: 16,
  },
  {
    id: "6",
    title: "Boosting Productivity with VS Code",
    description: "Tips, tricks, and essential extensions to make Visual Studio Code your power tool.",
    author: "Eva",
    timestamp: "3 days ago",
    tags: ["Productivity", "VS Code"],
    imageUrl: "https://picsum.photos/600/400?random=6",
    reactionCount: 27,
    commentCount: 6,
  },
  {
    id: "7",
    title: "Learning Python: A Beginner's Guide",
    description: "Get started with Python programming with practical examples and exercises.",
    author: "Frank",
    timestamp: "4 days ago",
    tags: ["Coding", "Python"],
    imageUrl: "https://picsum.photos/600/400?random=7",
    reactionCount: 30,
    commentCount: 10,
  },
  {
    id: "8",
    title: "Exploring the World of Data Science",
    description: "Data science and analytics explained with real-world projects and examples.",
    author: "Grace",
    timestamp: "5 days ago",
    tags: ["Data Science", "Analytics"],
    imageUrl: "https://picsum.photos/600/400?random=8",
    reactionCount: 22,
    commentCount: 7,
  },
];


----- /home/zakaria/zBlog/zblog-frontend/src/app/posts/[id]/page.tsx -----
"use client";

import React, { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { useAuth } from "react-oidc-context";
import DOMPurify from "dompurify";
import { getPost, PostDTO } from "@/services/postService";
import PostDetail from "@/components/posts/PostDetail/PostDetail";
import Fallback from "@/components/Fallback/Fallback";
import ErrorBoundary from "@/components/Fallback/ErrorBoundary";
import { useTogglePostReaction } from "@/hooks/post/useTogglePostReaction";

export default function SinglePostPage() {
  const params = useParams();
  const auth = useAuth();
  const postIdParam =
    typeof params?.id === "string"
      ? params.id
      : Array.isArray(params?.id)
      ? params.id[0]
      : "";

  const [post, setPost] = useState<PostDTO | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { toggle: togglePostReaction } = useTogglePostReaction();

  useEffect(() => {
    if (!auth.isLoading && auth.user) {
      const token = auth.user.access_token;
      getPost(postIdParam, token)
        .then((data) => {
          if (!data.id) {
            throw new Error("Post ID is missing in response");
          }
          setPost(data);
          setLoading(false);
        })
        .catch((err) => {
          setError(err.message || "Error loading post");
          setLoading(false);
        });
    }
  }, [postIdParam, auth]);

  if (auth.isLoading || loading) {
    return <Fallback message="Loading post..." />;
  }

  if (error) {
    return <Fallback message={`Error: ${error}`} />;
  }

  if (!post || !post.id) {
    return <Fallback message="No post found." />;
  }

  const safeContent = DOMPurify.sanitize(post.content);

  const handleLike = async () => {
    if (auth.user && post.id) {
      const updatedPost = await togglePostReaction(
        post.id,
        "like",
        auth.user.access_token
      );
      if (updatedPost) {
        setPost(updatedPost);
      }
    }
  };

  const handleBookmark = async () => {
    if (auth.user && post.id) {
      const updatedPost = await togglePostReaction(
        post.id,
        "bookmark",
        auth.user.access_token
      );
      if (updatedPost) {
        setPost(updatedPost);
      }
    }
  };

  const handleShare = async () => {
    navigator.clipboard.writeText(window.location.href);
    alert("Post URL copied to clipboard!");
  };

  const handleCommentClick = () => {
    document
      .getElementById("comment-section")
      ?.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <ErrorBoundary fallback={<Fallback message="Something went wrong rendering the post." />}>
      <PostDetail
        post={{
          id: post.id,
          title: post.title,
          coverImageUrl: post.bannerImageUrl || "/default-cover.jpg",
          content: safeContent,
          tags: post.tags || [],
          publishedAt: post.createdAt ? new Date(post.createdAt) : new Date(),
          author: {
            name: post.authorId ? `User ${post.authorId.substring(0, 6)}` : "Unknown Author",
            avatarUrl: "/avatars/default.png",
          },
        }}
        onLike={handleLike}
        onBookmark={handleBookmark}
        onShare={handleShare}
        onCommentClick={handleCommentClick}
      />
    </ErrorBoundary>
  );
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/controller/HealthCheckController.java -----
package com.zblog.zblogpostcore.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/post/health")
public class HealthCheckController {

    @GetMapping
    public String health() {
        return "OK";
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/controller/TagController.java -----
package com.zblog.zblogpostcore.controller;

import com.zblog.zblogpostcore.service.TagService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/post/api/tags")
public class TagController {

    private final TagService tagService;

    @Autowired
    public TagController(TagService tagService) {
        this.tagService = tagService;
    }

    // GET /api/tags -> returns a list of tag names
    @GetMapping
    public List<String> getAllTags() {
        return tagService.listAllTags().stream()
                .map(tag -> tag.getName())
                .collect(Collectors.toList());
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/controller/PostController.java -----
package com.zblog.zblogpostcore.controller;

import com.zblog.zblogpostcore.dto.PostDTO;
import com.zblog.zblogpostcore.dto.PostDetailDTO;
import com.zblog.zblogpostcore.service.PostService;
import com.zblog.zblogpostcore.util.SecurityUtil;
import jakarta.mail.internet.MimeMessage;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.constraints.Pattern;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/post/api/posts")
@Validated
public class PostController {

    private final PostService postService;
    private final JavaMailSender mailSender;

    @Autowired
    public PostController(PostService postService, JavaMailSender mailSender) {
        this.postService = postService;
        this.mailSender = mailSender;
    }

    /**
     * Explore posts with optional filtering by keywords and tags, sorting, and pagination.
     *
     * Query parameters:
     * - tags: comma-separated list (optional)
     * - keywords: full-text search (optional)
     * - sort: "recent", "popular", or "mostLiked" (defaults to "recent")
     * - page & size: pagination controls
     */
    @GetMapping("/explore")
    public Page<PostDTO> explorePosts(
            @RequestParam(required = false) String tags,
            @RequestParam(required = false) String keywords,
            @RequestParam(defaultValue = "recent")
            @Pattern(regexp = "recent|popular|mostLiked", message = "Invalid sort value")
            String sort,
            Pageable pageable) {

        String currentUserId = SecurityUtil.getCurrentUserIdOrNull();
        List<String> tagList = (tags != null && !tags.isBlank())
                ? List.of(tags.split(",")).stream().map(String::trim).filter(s -> !s.isEmpty()).collect(Collectors.toList())
                : null;
        return postService.explorePosts(keywords, tagList, sort, pageable, currentUserId);
    }

    // CREATE
    @PostMapping
    public PostDTO createPost(@RequestBody PostDTO postDTO) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        return postService.createPost(postDTO, currentUserId);
    }

    // READ (single post)
    @GetMapping("/{postId}")
    public PostDetailDTO getPost(@PathVariable("postId") UUID postId) {
        String currentUserId = SecurityUtil.getCurrentUserIdOrNull();
        return postService.getFullPost(postId, currentUserId);
    }

    // UPDATE
    @PutMapping("/{postId}")
    public PostDTO updatePost(@PathVariable("postId") UUID postId, @RequestBody PostDTO postDTO) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        return postService.updatePost(postId, postDTO, currentUserId);
    }

    // DELETE
    @DeleteMapping("/{postId}")
    public void deletePost(@PathVariable("postId") UUID postId) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        postService.deletePost(postId, currentUserId);
    }

    // LIST/PAGINATION - gets all or only published
    @GetMapping
    public Page<PostDTO> getAllPosts(@RequestParam(value = "publishedOnly", defaultValue = "true") boolean publishedOnly,
                                     Pageable pageable) {
        return postService.getAllPosts(publishedOnly, pageable);
    }

    // SEARCH
    @GetMapping("/search")
    public Page<PostDTO> searchPosts(@RequestParam("keyword") String keyword,
                                     @RequestParam(value = "publishedOnly", defaultValue = "true") boolean publishedOnly,
                                     Pageable pageable) {
        return postService.searchPosts(keyword, publishedOnly, pageable);
    }

    // LIST BY AUTHOR
    @GetMapping("/by-author/{authorId}")
    public Page<PostDTO> getPostsByAuthor(@PathVariable("authorId") String authorId,
                                          @RequestParam(value = "publishedOnly", defaultValue = "true") boolean publishedOnly,
                                          Pageable pageable) {
        return postService.getPostsByAuthor(authorId, publishedOnly, pageable);
    }

    // INCREMENT VIEW COUNT
    @PatchMapping("/{postId}/view")
    public PostDTO incrementView(@PathVariable("postId") UUID postId) {
        return postService.incrementViewCount(postId);
    }

    // REACT
    @PatchMapping("/{postId}/react")
    public PostDTO react(@PathVariable("postId") UUID postId,
                         @RequestParam("type") String reactionType) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        return postService.reactToPost(postId, reactionType, currentUserId);
    }

    @PostMapping("/visit")
    public void logVisit(@RequestBody Map<String, Object> body, HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty()) {
            ip = request.getRemoteAddr();
        }

        String userId = SecurityUtil.getCurrentUserIdOrNull();
        String type = (String) body.get("type");

        if ("view_all_posts".equals(type)) {
            Integer page = (Integer) body.get("page");
            Integer size = (Integer) body.get("size");
            Boolean publishedOnly = (Boolean) body.get("publishedOnly");

            System.out.printf("User %s viewed all posts (page=%d, size=%d, publishedOnly=%s) from IP %s%n",
                    userId, page, size, publishedOnly, ip);

        } else if ("view_single_post".equals(type)) {
            String postId = (String) body.get("postId");

            System.out.printf("User %s viewed post %s from IP %s%n", userId, postId, ip);
        }

        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true);
            helper.setTo("zakariafarih142@gmail.com");
            helper.setSubject("New IP Accessed Your App");
            helper.setText("A new IP accessed the endpoint: " + ip);
            mailSender.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/client/FileClient.java -----
package com.zblog.zblogpostcore.client;

import com.zblog.zblogpostcore.client.dto.FileMetadataDTO;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

/**
 * A REST-based client to communicate with the s3-core microservice.
 * This ensures post-core does NOT rely on s3-core's Java code,
 * but only on a well-defined REST contract.
 */
@Component
public class FileClient {

    private final RestTemplate restTemplate;
    private final String s3CoreUrl;

    public FileClient(@Value("${s3.core.url}") String s3CoreUrl,
                      RestTemplateBuilder restTemplateBuilder) {
        this.s3CoreUrl = s3CoreUrl;
        this.restTemplate = restTemplateBuilder.build();
    }

    /**
     * Retrieve metadata (including a presigned URL) for a given fileId.
     * The s3-core endpoint is assumed:
     *  GET /internal/files/{fileId}?public=false
     * returning JSON with the final presigned or public URL.
     */
    @CircuitBreaker(name = "s3CoreCircuitBreaker", fallbackMethod = "getFileMetadataFallback")
    @Retry(name = "s3CoreRetry")
    public FileMetadataDTO getFileMetadata(String fileId, boolean isPublic) {
        String url = String.format("%s/s3/files/%s?public=%s", s3CoreUrl, fileId, isPublic);
        ResponseEntity<FileMetadataDTO> response = restTemplate.getForEntity(url, FileMetadataDTO.class);
        return response.getBody();
    }

    /**
     * Delete a file from s3-core.
     * The s3-core endpoint is:
     *  DELETE /internal/files/{fileId}
     */
    @CircuitBreaker(name = "s3CoreCircuitBreaker", fallbackMethod = "deleteFileFallback")
    @Retry(name = "s3CoreRetry")
    public void deleteFile(String fileId) {
        String url = String.format("%s/internal/files/%s", s3CoreUrl, fileId);
        restTemplate.exchange(url, HttpMethod.DELETE, null, Void.class);
    }

    // --- Fallbacks if s3-core is unreachable ---

    private FileMetadataDTO getFileMetadataFallback(String fileId, boolean isPublic, Throwable t) {
        // Return an empty or placeholder object
        FileMetadataDTO fallback = new FileMetadataDTO();
        fallback.setKey(fileId);
        fallback.setUrl(null);
        fallback.setMimeType(null);
        fallback.setSize(0);
        return fallback;
    }

    private void deleteFileFallback(String fileId, Throwable t) {
        // Possibly log or do nothing. The file won't get deleted in s3.
        // You could queue a retry or mark "orphan" file references.
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-post-core/src/main/java/com/zblog/zblogpostcore/client/dto/FileMetadataDTO.java -----
package com.zblog.zblogpostcore.client.dto;

import java.time.Instant;

/**
 * Mirrors the file response from s3-core:
 * GET /internal/files/{fileId}
 */
public class FileMetadataDTO {
    private String key;
    private long size;
    private String mimeType;
    private Instant uploadTimestamp;
    private String url; // final presigned or public URL

    public String getKey() { return key; }
    public void setKey(String key) { this.key = key; }

    public long getSize() { return size; }
    public void setSize(long size) { this.size = size; }

    public String getMimeType() { return mimeType; }
    public void setMimeType(String mimeType) { this.mimeType = mimeType; }

    public Instant getUploadTimestamp() { return uploadTimestamp; }
    public void setUploadTimestamp(Instant uploadTimestamp) { this.uploadTimestamp = uploadTimestamp; }

    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-comment-core/src/main/java/com/zblog/zblogcommentcore/client/PostCoreClient.java -----
package com.zblog.zblogcommentcore.client;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.UUID;

@Service
public class PostCoreClient {

    private final RestTemplate restTemplate;

    @Value("${post.core.url}") // e.g. http://post-core-service:8081
    private String postCoreBaseUrl;

    public PostCoreClient(RestTemplateBuilder builder) {
        this.restTemplate = builder.build();
    }

    public void validatePostExists(UUID postId, String accessToken) {
        try {
            String fullUrl = postCoreBaseUrl.endsWith("/")
                    ? postCoreBaseUrl + "post/api/posts/" + postId
                    : postCoreBaseUrl + "/post/api/posts/" + postId;

            HttpHeaders headers = new HttpHeaders();
            headers.setBearerAuth(accessToken);

            HttpEntity<Void> entity = new HttpEntity<>(headers);
            // If the GET fails (e.g. 404, 401) an exception is thrown.
            restTemplate.exchange(fullUrl, HttpMethod.GET, entity, Object.class);
        } catch (Exception ex) {
            throw new IllegalArgumentException("Post check failed: " + postId, ex);
        }
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-comment-core/src/main/java/com/zblog/zblogcommentcore/client/FileClient.java -----
package com.zblog.zblogcommentcore.client;

import com.zblog.zblogcommentcore.client.dto.FileMetadataDTO;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
public class FileClient {

    private final RestTemplate restTemplate;
    private final String s3CoreUrl;

    public FileClient(@Value("${s3.core.url}") String s3CoreUrl,
                      RestTemplateBuilder builder) {
        this.s3CoreUrl = s3CoreUrl;
        this.restTemplate = builder.build();
    }

    @CircuitBreaker(name = "s3CoreCb", fallbackMethod = "getFileFallback")
    @Retry(name = "s3CoreRetry")
    public FileMetadataDTO getFileMetadata(String fileId, boolean isPublic) {
        String url = String.format("%s/s3/files/%s?public=%s", s3CoreUrl, fileId, isPublic);
        ResponseEntity<FileMetadataDTO> resp = restTemplate.getForEntity(url, FileMetadataDTO.class);
        return resp.getBody();
    }

    @CircuitBreaker(name = "s3CoreCb", fallbackMethod = "deleteFileFallback")
    @Retry(name = "s3CoreRetry")
    public void deleteFile(String fileId) {
        String url = String.format("%s/s3/internal/files/%s", s3CoreUrl, fileId);
        restTemplate.exchange(url, HttpMethod.DELETE, null, Void.class);
    }

    // fallback methods
    private FileMetadataDTO getFileFallback(String fileId, boolean isPublic, Throwable t) {
        FileMetadataDTO fm = new FileMetadataDTO();
        fm.setKey(fileId);
        fm.setUrl(null);
        return fm;
    }
    private void deleteFileFallback(String fileId, Throwable t) {
        // do nothing or log
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-comment-core/src/main/java/com/zblog/zblogcommentcore/client/dto/FileMetadataDTO.java -----
package com.zblog.zblogcommentcore.client.dto;

import java.time.Instant;

public class FileMetadataDTO {
    private String key;
    private long size;
    private String mimeType;
    private Instant uploadTimestamp;
    private String url;

    // getters/setters

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public long getSize() {
        return size;
    }

    public void setSize(long size) {
        this.size = size;
    }

    public String getMimeType() {
        return mimeType;
    }

    public void setMimeType(String mimeType) {
        this.mimeType = mimeType;
    }

    public Instant getUploadTimestamp() {
        return uploadTimestamp;
    }

    public void setUploadTimestamp(Instant uploadTimestamp) {
        this.uploadTimestamp = uploadTimestamp;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-comment-core/src/main/java/com/zblog/zblogcommentcore/controller/HealthCheckController.java -----
package com.zblog.zblogcommentcore.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/comment/health")
public class HealthCheckController {

    @GetMapping
    public String health() {
        return "OK";
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-comment-core/src/main/java/com/zblog/zblogcommentcore/controller/CommentController.java -----
package com.zblog.zblogcommentcore.controller;

import com.zblog.zblogcommentcore.dto.*;
import com.zblog.zblogcommentcore.service.CommentService;
import com.zblog.zblogcommentcore.service.CommentReactionService;
import com.zblog.zblogcommentcore.util.SecurityUtil;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/comment/api/comments")
@Validated
public class CommentController {

    private final CommentService commentService;
    private final CommentReactionService reactionService;

    @Autowired
    public CommentController(CommentService commentService,
                             CommentReactionService reactionService) {
        this.commentService = commentService;
        this.reactionService = reactionService;
    }

    @PostMapping
    public CommentResponseDTO createComment(@Valid @RequestBody CommentCreateRequest request) {
        // Obtain the current JWT access token for post validation
        String token = SecurityUtil.getCurrentAccessToken();
        String currentUserId = SecurityUtil.getCurrentUserId();
        return commentService.createComment(request, currentUserId, token);
    }

    @PutMapping("/{commentId}")
    public CommentResponseDTO updateComment(@PathVariable("commentId") UUID commentId,
                                            @Valid @RequestBody CommentUpdateRequest request) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        request.setId(commentId); // ensure ID matches
        return commentService.updateComment(request, currentUserId);
    }

    @DeleteMapping("/{commentId}")
    public void deleteComment(@PathVariable("commentId") UUID commentId) {
        String currentUserId = SecurityUtil.getCurrentUserId();
        commentService.deleteComment(commentId, currentUserId);
    }

    @GetMapping("/post/{postId}")
    public Page<CommentResponseDTO> getTopLevelComments(@PathVariable("postId") UUID postId,
                                                        Pageable pageable) {
        return commentService.getTopLevelComments(postId, pageable);
    }

    @GetMapping("/{commentId}")
    public CommentResponseDTO getComment(@PathVariable("commentId") UUID commentId) {
        return commentService.getComment(commentId);
    }

    @GetMapping("/{commentId}/thread")
    public CommentResponseDTO getCommentThread(@PathVariable("commentId") UUID commentId) {
        return commentService.buildCommentThread(commentId);
    }

    /**
     * Toggle a reaction. If the user already has the reaction, remove it;
     * otherwise, create it. Then return the full updated comment (with new counts).
     */
    @PatchMapping("/{commentId}/react")
    public CommentResponseDTO toggleReaction(@PathVariable("commentId") UUID commentId,
                                             @RequestParam("type") String reactionType) {
        String userId = SecurityUtil.getCurrentUserId();
        reactionService.toggleReaction(commentId, userId, reactionType);
        // After toggling, return the updated comment with refreshed reaction counts
        return commentService.getComment(commentId);
    }
}


----- /home/zakaria/zBlog/zblog-backend/zblog-comment-core/src/main/java/com/zblog/zblogcommentcore/repository/CommentRepository.java -----
package com.zblog.zblogcommentcore.repository;

import com.zblog.zblogcommentcore.domain.entity.Comment;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.UUID;

public interface CommentRepository extends JpaRepository<Comment, UUID> {

    // Retrieve top-level comments for a post
    Page<Comment> findByPostIdAndParentIdIsNullOrderByCreatedAtAsc(UUID postId, Pageable pageable);

    // Retrieve child comments for a given parent
    List<Comment> findByParentIdOrderByCreatedAtAsc(UUID parentId);

    // All comments for a post (if needed)
    Page<Comment> findByPostIdOrderByCreatedAtAsc(UUID postId, Pageable pageable);
}


----- /home/zakaria/zBlog/zblog-backend/zblog-comment-core/src/main/java/com/zblog/zblogcommentcore/repository/CommentReactionRepository.java -----
package com.zblog.zblogcommentcore.repository;

import com.zblog.zblogcommentcore.domain.entity.CommentReaction;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface CommentReactionRepository extends JpaRepository<CommentReaction, UUID> {

    // For toggling: see if the user already reacted
    Optional<CommentReaction> findByUserIdAndCommentIdAndReactionType(
            String userId, UUID commentId, String reactionType);

    // fetch all user reactions for a comment
    List<CommentReaction> findByUserIdAndCommentId(String userId, UUID commentId);

    // For counting (like summary)
    Long countByCommentIdAndReactionType(UUID commentId, String reactionType);
}


